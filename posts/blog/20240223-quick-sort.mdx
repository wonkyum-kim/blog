---
title: Quick sort
date: 2024-02-23
description: 퀵 정렬에 사용되는 분할 방법들
tags:
  - Algorithm
---

## 퀵 정렬

`퀵 정렬(quick sort)`는 분할 정복에 기반을 두고 있는 정렬입니다.

- 분할: `A[p .. r]` 배열을, `A[p .. q - 1]`과 `A[q + 1 .. r]` 두 부분 배열로 분할하고, 각각 `A[q]` 보다 작거나 같은 원소와 크거나 같은 원소들을 배치합니다.
- 정복: 재귀 호출을 통해서 각 부분 배열을 정렬합니다.
- 결합: 병합 정렬과는 다르게 내부적으로 배열을 정렬하므로, 별도의 결합 과정은 거치지 않습니다.

```
quick-sort(A, p, r)
	if p < r
		// 두 부분 배열로 분할할 기준점을 정한다.
		q = partition(A, p, r)
		// 재귀 호출을 통해 두 부분 배열을 정렬한다.
		quick-sort(A, p, q - 1)
		quick-sort(A, q + 1, r)
```

```
partition(A, p, r)
	// 맨 마지막 원소를 기준으로 정한다.
	x = A[r]
	i = p - 1
	// A[r] 보다 작은 원소들과 큰 원소들을 분리한다.
	for j = p to r - 1
		if A[j] <= x
			i++
			swap A[i] with A[j]
	swap A[i + 1] with A[r]
	return i + 1
```

## 분할을 가장 나쁘게 하는 경우

분할이 가장 나쁘게 되는 경우는 두 부분 배열의 크기가 각각 0과 n - 1이 되는 것입니다.

$T(n) = T(n - 1) + T(0) + \theta(n) = \theta(n^2)$ 시간이 걸리게 됩니다.

## 분할을 가장 잘하는 경우

분할이 가장 잘되는 경우는 두 부분 배열의 크기가 각각 n / 2 이하가 되는 것입니다.

$T(n) = 2T(n/2) + \theta(n) = \theta(n \log n)$시간이 걸리게 됩니다.

## 분할이 항상 균등하게 되는 경우

예를 들어 각 부분 배열의 크기가 9 대 1로 이루어진다고 생각해봅시다.

이는 나쁜 분할이라고 생각할 수 있지만 계산을 해보면 좋은 수행 시간이 나옵니다.

$T(n) \leq T(9n/10) + T(n/10) + \theta(n) = O(n \log n)$

## 분할이 평균적으로 되는 경우

현실에서는 분할이 항상 균등하게 일어나지 않고, 나쁜 분할과 좋은 분할이 번갈아 발생합니다.

직관적으로 예를 들어보면, 나쁜 분할이 먼저 일어나 각각 크기가 0, n - 1인 두 부분 배열으로 분할 되고, 이후 좋은 분할이 일어나 크기가 (n - 1) / 2인 두 배열로 분할 되었다고 해봅시다.

여전히 좋은 분할만 일어났을 때와 마찬가지로 $O(n \log n)$ 시간이 걸리게 됩니다.

## 랜덤을 적용하는 경우

분할이 되는 기준 원소를 맨 마지막 원소가 아닌, 랜덤을 적용하여 성능의 기댓값을 높일 수 있습니다.

- `A[r]`을 선택하는 대신에 임의의 원소를 선택 후, `A[r]`과 교환하는 방법
- 무작위로 3개의 원소를 선택 후 중앙값을 선택하고 `A[r]`과 교환하는 방법
