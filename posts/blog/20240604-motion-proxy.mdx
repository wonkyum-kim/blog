---
title: framer-motion의 두 가지 사용 방법
date: 2024-06-04
description: 어떻게 두 가지 방법으로 사용할 수 있는가?
tags:
  - Framer-Motion
---

## motion의 사용 방법

`framer-motion`에서 `motion`을 사용하는 방법은 2가지가 있다.

- `motion()`에 React 컴포넌트를 건네주기
- `<motion.div />`와 같이 JSX 형태로 사용하기

![](/posts/20240604/motion1.png)

어떻게 2가지 방법을 모두 지원할 수 있는 것인가?

그 이유는 `Proxy 패턴`을 사용하기 때문이다.

## Proxy 패턴

Proxy는 특정 객체를 감싸 프로퍼티 읽기, 쓰기와 같은 객체에 가해지는 작업을 중간에서 가로채는 객체를 의미한다.

framer-motion은 Proxy의 get트랩을 사용한 흥미로운 방법을 제시하고 있다.

Proxy가 객체를 감싸고, 객체의 프로퍼티에 접근하면 get 트랩이 발동한다.

Proxy는 객체 뿐만 아니라 함수도 감쌀 수 있는데, 함수의 경우 get 트랩은 작동하지 않는다.

```js
function foo(a) {
  return a;
}

foo = new Proxy(foo, {
  get: (_target, key) => {
    console.log('Proxy!');
    return key;
  },
});

foo('div'); // get 트랩이 적용되지 않음
foo['div']; // get 트랩이 적용됨, 'Proxy!' 출력
```

(만약 함수에서 프록시 패턴을 적용하고 싶다면, apply 트랩을 사용하면 된다.)

framer-motion은 이 점을 노려서 motion이 함수로 호출되었을 때는 무시하고, 객체로서 호출되었을 때는 get 트랩을 적용시키는 방법을 사용한다.

## createMotionProxy

`motion`은 아래와 같이 정의되어 있다.

```ts
// framer-motion/src/render/dom/motion.ts
export const motion = /*@__PURE__*/ createMotionProxy(
  (Component, config) =>
    createDomMotionConfig(
      Component,
      config,
      preloadedFeatures,
      createDomVisualElement
    ) as any
);
```

`createMotionProxy`를 살펴보면 아래와 같다.

```ts
// framer-motion/src/render/dom/motion-proxy.ts
export function createMotionProxy(createConfig: CreateConfig) {
  function custom<Props extends {}>(
    Component: string | React.ComponentType<React.PropsWithChildren<Props>>,
    customMotionComponentConfig: CustomMotionComponentConfig = {}
  ): CustomDomComponent<Props> {
    return createMotionComponent<
      Props,
      HTMLElement | SVGElement,
      HTMLRenderState | SVGRenderState
    >(createConfig(Component, customMotionComponentConfig));
  }

  if (typeof Proxy === 'undefined') {
    return custom as typeof custom & DOMMotionComponents;
  }

  /**
   * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.
   * Rather than generating them anew every render.
   */
  const componentCache = new Map<string, any>();

  return new Proxy(custom, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key: string) => {
      /**
       * If this element doesn't exist in the component cache, create it and cache.
       */
      if (!componentCache.has(key)) {
        componentCache.set(key, custom(key));
      }

      return componentCache.get(key)!;
    },
  }) as typeof custom & DOMMotionComponents;
}
```

마지막에 `custom`이라는 함수를 감싼 Proxy를 반환하고 있다.

따라서 `motion(Component)`과 같이 호출한다면, get 트랩은 발동하지 않고 `custom(Component)`이 호출된다.

하지만 `motion.div`와 같이 호출한다면, get 트랩은 발동되고 캐싱 과정을 거친 다음, `custom('div')`가 호출된다.

![](/posts/20240604/motion2.png)

`custom`이 하는 역할은, React 컴포넌트를 motion 컴포넌트로 바꿔주거나, 해당 HTML 태그에 해당하는 motion 컴포넌트를 생성하는 것이다.
