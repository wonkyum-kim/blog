---
title: Zustand create 분석해보기
date: 2023-12-20
description: create는 어떻게 동작하는가
tags:
  - FE
  - Zustand
---

## 전체 구조

![](/posts/20231220-zustand/create6.png)

## create

zustand의 [문서](https://docs.pmnd.rs/zustand/guides/typescript)에 가보면 가장 기초적인 사용예제가 나온다.

```ts
import { create } from 'zustand';

interface BearState {
  bears: number;
  increase: (by: number) => void;
}

const useBearStore = create<BearState>()((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
}));
```

`create`에 어떤 함수를 전달하는 것으로 `useBearStore`가 생성되어 반환된다.

실제 구현으로 가보자.

```ts
// src/react.ts
export const create = (<T>(createState: StateCreator<T, [], []> | undefined) =>
  createState ? createImpl(createState) : createImpl) as Create;
```

복잡하니까 내가 이해하기 쉽게 변경해보겠다.

```ts
export function create(createState) {
  return createState ? createImpl(createState) : createImpl;
}
```

`createState`가 undefined가 아니라면, `createImpl` 함수의 반환 값을 전달하고, undefined라면 `createImple` 그 자체를 전달한다.

위의 예제에서 `createState`는 아래와 같은 함수다.

```ts
const createState = (set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
});
```

딱히 실수하지 않는 이상 `undefined`를 전달할 일은 없을 것이므로 아래와 같이 더 간단하게 생각해보자.

```ts
export function create(createState) {
  return createImpl(createState);
}
```

결국 create는 `createImpl`의 단순 래퍼역할을 하고 있었다.

![](/posts/20231220-zustand/create1.png)

## createImpl

그러면 `createImpl`은 무엇인가?

```ts
// src/react.ts
const createImpl = <T>(createState: StateCreator<T, [], []>) => {
  if (
    import.meta.env?.MODE !== 'production' &&
    typeof createState !== 'function'
  ) {
    console.warn(
      "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
    );
  }
  const api =
    typeof createState === 'function' ? createStore(createState) : createState;

  const useBoundStore: any = (selector?: any, equalityFn?: any) =>
    useStore(api, selector, equalityFn);

  Object.assign(useBoundStore, api);

  return useBoundStore;
};
```

역시 복잡하므로 좀 더 단순화 시켜보자.

```ts
function createImpl(createState) {
  const api = createStore(createState);

  const useBoundStore = (selector?: any, equalityFn?: any) => {
    return useStore(api, selector, equalityFn);
  };

  Object.assign(useBoundStore, api);

  return useBoundStore;
}
```

`createStore`라는 함수가 등장하고, 이 함수는 `api`를 반환한다.

`useBoundStore`라는 함수를 정의하는데, 이 함수는 `useStore`의 반환 값을 반환한다.

그리고 이 둘을 합쳐서 반환한다.

여기서 알아봐야 할 것이 두 개가 생겼다.

1. api란 무엇인가?
2. useStore란 무엇인가?

![](/posts/20231220-zustand/create2.png)

### 1-1. createStore

먼저 `createStore`를 살펴보자. api란 무엇일까?

```ts
// src/vanilla.ts
export const createStore = ((createState) =>
  createState ? createStoreImpl(createState) : createStoreImpl) as CreateStore;
```

마찬가지로 복잡하니 단순화 시켜보면,

```ts
export function createStore(createState) {
  return createStoreImpl(createState);
}
```

마찬가지로 `createStoreImpl`의 단순 래퍼였다.

zustand에서는 이런 식의 래퍼 함수를 많이 사용하고 있었다.

### 1-2. createStoreImpl

```ts
// src/vanilla.ts
const createStoreImpl: CreateStoreImpl = (createState) => {
  type TState = ReturnType<typeof createState>;
  type Listener = (state: TState, prevState: TState) => void;
  let state: TState;
  const listeners: Set<Listener> = new Set();

  const setState: StoreApi<TState>['setState'] = (partial, replace) => {
    // TODO: Remove type assertion once https://github.com/microsoft/TypeScript/issues/37663 is resolved
    // https://github.com/microsoft/TypeScript/issues/37663#issuecomment-759728342
    const nextState =
      typeof partial === 'function'
        ? (partial as (state: TState) => TState)(state)
        : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state =
        replace ?? (typeof nextState !== 'object' || nextState === null)
          ? (nextState as TState)
          : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };

  const getState: StoreApi<TState>['getState'] = () => state;

  const getInitialState: StoreApi<TState>['getInitialState'] = () =>
    initialState;

  const subscribe: StoreApi<TState>['subscribe'] = (listener) => {
    listeners.add(listener);
    // Unsubscribe
    return () => listeners.delete(listener);
  };

  const destroy: StoreApi<TState>['destroy'] = () => {
    if (import.meta.env?.MODE !== 'production') {
      console.warn(
        '[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.'
      );
    }
    listeners.clear();
  };

  const api = { setState, getState, getInitialState, subscribe, destroy };
  const initialState = (state = createState(setState, getState, api));
  return api as any;
};
```

복잡하니 단순화 시켜보면, 아래와 같다.

```ts
function createStoreImpl(createState) {
  let state;
  const listeners = new Set();

  const setState = (partial) => {
    const nextState = partial(state);

    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };

  const getState = () => state;

  const getInitialState = () => initialState;

  const subscribe = (listener) => {
    listeners.add(listener);
    // Unsubscribe
    return () => listeners.delete(listener);
  };

  const destroy = () => {
    listeners.clear();
  };

  const api = { setState, getState, getInitialState, subscribe, destroy };

  const initialState = (state = createState(setState, getState, api));

  return api;
}
```

![](/posts/20231220-zustand/create3.png)

이제 하나씩 살펴보자.

- getState : `state` 변수를 클로저를 사용해 불러오는 역할을 하는 함수다.
- setState : `state` 를 `nextState`로 업데이트하고, 콜백 함수들을 실행하는 함수다.
- subscribe: 콜백 함수들을 `listeners`에 등록하는 함수다.
- destory: 콜백 함수들을 `listerners`에서 제거하는 함수다.
- getIninitalState: 서버에서 사용할 상태를 만들고 가져오는 함수다.

즉, api는 상태를 가져오거나 변경하는 함수들을 담아둔 객체다.

![](/posts/20231220-zustand/create4.png)

### 2-1. useStore

`useBoundStore`를 다시 살펴보자.

`useStore`의 반환 값을 반환하는 함수였다.

```ts
const useBoundStore = (selector?: any, equalityFn?: any) => {
  return useStore(api, selector, equalityFn);
};
```

`useStore`를 분석해보자.

```ts
// src/react.ts

export function useStore<TState, StateSlice>(
  api: WithReact<StoreApi<TState>>,
  selector: (state: TState) => StateSlice = identity as any,
  equalityFn?: (a: StateSlice, b: StateSlice) => boolean
) {
  if (
    import.meta.env?.MODE !== 'production' &&
    equalityFn &&
    !didWarnAboutEqualityFn
  ) {
    console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    );
    didWarnAboutEqualityFn = true;
  }
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue(slice);
  return slice;
}
```

마찬가지로 단순화 시켜보면, 아래와 같다.

```ts
export function useStore(api, selector, equalityFn) {
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue(slice);
  return slice;
}
```

### 2-2. useSyncExternalStoreWithSelector

`useSyncExternalStoreWithSelector`는 무엇인가?

이를 알아보려면 먼저 `useSyncExternalStore`에 대해서 알아봐야한다.

[리액트 문서](https://react.dev/reference/react/useSyncExternalStore)에서는 이렇게 소개하고 있다.

> useSyncExternalStore is a React Hook that lets you subscribe to an external store.

즉, 리액트 외부의 값에 대해서 구독하게 해주는 리액트 훅이라는 것인데

쉽게 얘기하면 외부 값이 변하면 알아서 재렌더링을 유발시켜 준다는 의미다.

zustand는 리액트 외부의 값이니 재렌더링을 하기 위해 이 훅을 사용해야 한다.

`useSyncExternalStoreWithSelector`는 여기에 더해서 `selector`와 `equalityFn`을 받는다는 차이점이 있다.

이 차이점이 대체 무엇을 의미할까?

직접 [리액트 코드](https://github.com/facebook/react/blob/main/packages/use-sync-external-store/src/useSyncExternalStoreWithSelector.js)를 살펴보자. 그런데 다 보는 것은 너무 기니까 조금 잘라서 보도록 하자.

```ts
// Same as useSyncExternalStore, but supports selector and isEqual arguments.
```

시작부터 주석으로 selector와 isEqual 빼고 동일하다고 적혀있다.

```ts
export function useSyncExternalStoreWithSelector<Snapshot, Selection>(
  subscribe: (() => void) => () => void,
  getSnapshot: () => Snapshot,
  getServerSnapshot: void | null | (() => Snapshot),
  selector: (snapshot: Snapshot) => Selection,
  isEqual?: (a: Selection, b: Selection) => boolean,
): Selection {
  // ...

  const [getSelection, getServerSelection] = useMemo(() => {
    // 여기서 selector, isEqual 사용함
  });

  // ...

  const value = useSyncExternalStore(
    subscribe,
    getSelection,
    getServerSelection,
  );

  return value;
}
```

selector로 값의 일부를 빼와서 useMemo에 저장하고, isEqual로 이전 값과 동일한지 비교하는 내부 동작을 거친다.

그리고 이것을 다시 `useSyncExternalStore`에 넘겨준다.

즉, 값의 일부만 비교하여 전체가 재렌더링 하지 않도록 최적화를 하기 위해 사용하고 있는 것으로 추정된다.

![](/posts/20231220-zustand/create5.png)

## References

- [Zustand](https://github.com/pmndrs/zustand/tree/main)
- [useSyncExternalStore](https://react.dev/reference/react/useSyncExternalStore)
- [useSyncExternalStoreWithSelector](https://github.com/facebook/react/blob/main/packages/use-sync-external-store/src/useSyncExternalStoreWithSelector.js)
