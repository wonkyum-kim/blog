---
title: Next.js 인라인 서버 액션과 클로저
date: 2024-04-11
description: 인라인 서버 액션은 쓰지 말자
tags:
  - Next.js
---

## 인라인 서버 액션

알다시피 서버 컴포넌트 내에서는 인라인으로 서버 액션을 정의할 수 있다.

```tsx
// Server Component
export default function Page() {
  // Server Action
  async function create() {
    'use server'

    // ...
  }

  return (
    // ...
  )
}
```

공식 문서에서 [인라인으로 서버 액션을 다룰 경우 클로저를 사용할 때 보안 문제를 어떻게 해결하는가](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations#closures-and-encryption)에 대한 글을 읽게 되었다.

생각해보면, 서버 액션은 서버에서 실행되는 비동기 함수다.

서버 액션이 서버 컴포넌트의 변수를 가져다 쓰는 것은 별 상관이 없을 것 같은데,

서버 컴포넌트 내의 변수 값을 서버 액션에서 변경해버리면, 이 변수 값이 클라이언트에 노출되고, 이 값이 민감한 값일 경우 보안 문제가 발생할 수 있다는 글이었다.

이를 해결하기 위해 Next.js는 빌드할 때마다 액션마다 새로운 개인 키를 생성하고 자동적으로 클로저 값을 암호화 시킨다고 한다.

암호화는 내가 전혀 알지 못하는 부분이기에 그냥 코드만 살짝 살펴보았다.

## encryption-utils.ts

서버 액션에서 변수를 암호화 하는 코드는 [`encryption-utils.ts`](https://github.com/vercel/next.js/blob/canary/packages/next/src/server/app-render/encryption-utils.ts)와 [`encryption.ts`](https://github.com/vercel/next.js/blob/canary/packages/next/src/server/app-render/encryption.ts)에서 찾아볼 수 있는 것 같았다.

```ts
export function encrypt(key: CryptoKey, iv: Uint8Array, data: Uint8Array) {
  return crypto.subtle.encrypt(
    {
      name: 'AES-GCM',
      iv,
    },
    key,
    data
  );
}

export function decrypt(key: CryptoKey, iv: Uint8Array, data: Uint8Array) {
  return crypto.subtle.decrypt(
    {
      name: 'AES-GCM',
      iv,
    },
    key,
    data
  );
}
```

암호화를 하기 위해서 [`Web Crypto API`](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API)를 사용하는 것을 확인했다.

```ts
export async function getActionEncryptionKey() {
  if (__next_loaded_action_key) {
    return __next_loaded_action_key;
  }

  const serverActionsManifestSingleton = (globalThis as any)[
    SERVER_ACTION_MANIFESTS_SINGLETON
  ] as {
    clientReferenceManifest: ClientReferenceManifest;
    serverActionsManifest: ActionManifest;
  };

  if (!serverActionsManifestSingleton) {
    throw new Error(
      'Missing manifest for Server Actions. This is a bug in Next.js'
    );
  }

  const rawKey =
    process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY ||
    serverActionsManifestSingleton.serverActionsManifest.encryptionKey;

  if (rawKey === undefined) {
    throw new Error('Missing encryption key for Server Actions');
  }

  __next_loaded_action_key = await crypto.subtle.importKey(
    'raw',
    stringToUint8Array(atob(rawKey)),
    'AES-GCM',
    true,
    ['encrypt', 'decrypt']
  );

  return __next_loaded_action_key;
}
```

액션마다 새로운 개인 키를 발급한다고 했는데, `getActionEncryptionKey`에서 진행하는 것으로 보인다.

개인 키 역시 `Web Crypto API`를 사용해서 만든다.

## encryption.ts

여기서는 `encryption-utils.ts`에서 만든 함수들을 사용해서 암호화와 복호화를 하는 과정을 거친다.

내부 코드는 생략했다.

```ts
async function decodeActionBoundArg(actionId: string, arg: string) {
  // ...
}

async function encodeActionBoundArg(actionId: string, arg: string) {
  // ...
}

export async function encryptActionBoundArgs(actionId: string, args: any[]) {
  // ...
}

export async function decryptActionBoundArgs(
  actionId: string,
  encrypted: Promise<string>
) {
  // ...
}
```

아마도 클로저 변수가 한 개일 때와 여러 개일 때 다른 함수가 필요해 보이는 듯 했다.

변수가 여러 개라면 직렬화를 하는 어떤 특수한 로직을 거치고, 한 개라면 그냥 arrayBuffer를 문자열로 바꾸는 과정을 진행하는 것 같다.

## 그냥 인라인 서버 액션은 쓰지 않는게 편할 것 같다.

이 과정을 살펴보니 암호화를 잘 해주는 것 같다는 생각이 들지만...

클로저를 안 쓴다고 생각하더라도 언젠가 실수로 사용할 수 도 있으니 그냥 인라인 서버 액션을 쓰지 않는 것이 더 낫다고 생각한다.

문서에서도 너무 의존하지는 말라고 적혀있기도 하다.

We don't recommend relying on encryption alone to prevent sensitive values from being exposed on the client. Instead, you should use the [React taint APIs](https://nextjs.org/docs/app/building-your-application/data-fetching/patterns#preventing-sensitive-data-from-being-exposed-to-the-client) to proactively prevent specific data from being sent to the client.

만약 인라인 서버 액션을 쓰지 않는데, 클로저가 필요한 상황이면 어떻게 해야 하는가?

문서에서 직접적인 해결책은 나오지 않지만 나는 `bind`를 사용해서 인자를 전달하는 방법이 가장 괜찮다고 생각한다.

이는 문서 다른 곳에서도 설명하고 있는 부분이기도 하다.

```tsx:app/client-component.tsx
'use client'

import { updateUser } from './actions'

export function UserProfile({ userId }: { userId: string }) {
  const updateUserWithId = updateUser.bind(null, userId)

  return (
    <form action={updateUserWithId}>
      <input type="text" name="name" />
      <button type="submit">Update User Name</button>
    </form>
  )
}
```

```ts:app/actions.ts
'use server'

export async function updateUser(userId, formData) {
  // ...
}
```

이 방법으로 컴포넌트 내의 변수의 복사본을 서버 액션에 전달하면 보안 문제를 해결할 수 있다.
