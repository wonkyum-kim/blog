---
title: 부분집합의 합(Sum over subsets)
date: 2023-12-24
description: 모든 부분 집합의 합을 빠르게 구하는 방법
tags:
  - Algorithm
---

## Subsets

예를 들어 다음과 같이 `v = [1, 2, 3, 4]`라는 배열이 있다고 해봅시다.

이 배열의 부분집합의 개수는 $2^4$개라는 것을 잘 알고 있습니다.

(= $_4C_0$ + $_4C_1$ + $_4C_2$ + $_4C_3$ + $_4C_4$)

그러면 각 부분집합마다 모든 원소를 더한 값은 어떻게 구할 수 있을까요?

예를 들어 `[1, 3, 4]`와 같은 부분집합은 8이 될 것이고, `[4]`와 같은 부분집합은 4가 될 것입니다.

이제 비트를 사용하는 방식으로 바꿔봅시다.

`A`라는 배열을 만들 것인데, 이 배열의 길이는 $2^4$라고 해봅시다.

그리고 `A[1 << i]`번째에 원래 배열의 원소를 배치해봅시다. (`A[1 << i] = v[i]`)

예를 들어 다음과 같습니다.

```cpp
A[1 << 0] = 1;
A[1 << 1] = 2;
A[1 << 2] = 3;
A[1 << 3] = 4;
```

그리고 함수 x & i = i인 모든 x에 대해서 `F(x)`를 다음과 같이 정의합니다.

$$F(x) = \sum{A[i]}$$

다시 말하면, x의 모든 비트 중에서 1인 것만 찾아서 다 더한 것이라고 할 수 있습니다.

예를 들어 x = 3이라고 한다면, 이진수로 표현하면 11(b)이고

`F(3) = A[1 << 0] + A[1 << 1] = 1 + 2 = 3`이 됩니다.

## Brute force

이를 brute force 코드로 옮겨보면 다음과 같습니다.

```cpp
int F[1 << 4];
int A[1 << 4];

// 배열 A에 원소를 넣는다.

for (int mask = 0; mask < (1 << N); ++mask) {
    for (int i = 0; i < (1 << N); ++i) {
        if ((mask & i) == i) {
            F[mask] += A[i];
        }
    }
}
```

이 코드는 $O(4^N)$시간이 걸리므로 매우 비효율적입니다.

## Sum Over Subsets DP

다시 한 번 정리해보겠습니다.

크기가 N인 집합의 원소들을 크기가 `[1 << N]`인 배열 A에 넣습니다.

그리고 크기가 N인 집합의 각 부분집합을 포함된 원소들의 인덱스를 사용해 0부터 $2^N - 1$ 사이의 정수로 나타낼 수 있습니다.

### 집합 S(mask, i)의 정의

이렇게 부분집합을 정수로 표현한 것을 `mask`라고 해봅시다.

집합 S(mask)를 다음과 같이 정의합니다.

> `S(mask)`: mask & x = x인 모든 x를 포함하는 집합.

즉, x는 mask의 부분집합을 나타내는 정수가 됩니다.

그리고 S(mask)를 더 확장하여 S(mask, i)를 정의합니다.

> `S(mask, i)`: mask에서 오른쪽부터 첫 i + 1개 (0부터 시작하기 때문에) 비트만 다른 x를 포함하는 집합.

예를 들어, S(**101**1010, 3) = [**101**1010, **101**0010, **101**1000, **101**0000]가 됩니다.

### i번째 비트가 0인 경우

이제 mask의 i번째 비트 (오른쪽에서 i + 1번째 비트)가 0이라고 가정해봅시다.

이것의 의미는 mask가 i번 원소를 가지고 있지 않다는 것입니다.

따라서 mask의 부분집합도 i번 원소를 가지고 있지 않는 것은 자명합니다.

마스크의 부분집합 중에서 i번째 비트가 0이 아닌 것은 없을 것입니다.

따라서, i번째 비트 이후로는 모두 같아야 하므로 첫 i - 1번째까지 비트에서만 다를 수 있는 가능성이 존재하게 됩니다.

S(mask, i) = S(mask, i - 1)

### i번째 비트가 1인 경우

mask의 i번째 비트가 1인 경우, 두 가지 가능성이 존재합니다.

왜냐하면 mask의 부분집합인 x는 i번 원소를 가질 수도 있고 안가질 수도 있기 때문입니다.

예를 들어, S(**10**110, 2)를 생각해 봅시다.

2번째 비트가 1이므로 x는 i번째 비트가 1이거나 (S(**101**10, 1))

2번째 비트가 0인 경우를 모두 포함합니다. (S(**100**10, 1))

S(mask, i) = S(mask, i-1) ∪ S(mask ⊕ 2^i, i - 1)

### 구현

이를 코드로 구현하면 아래와 같고, $O(N2^N)$시간이 걸립니다.

```cpp
int n = 4;
int v[4] = {1, 2, 3, 4}, dp[1 << 4];

void sos()
{
	for (int i = 0; i < n; ++i) {
		dp[1 << i] = v[i];
	}

	for (int i = 0; i < n; ++i) {
		for (int mask = 0; mask < (1 << n); ++mask) {
			if (mask & (1 << i)) {
				dp[mask] += dp[mask^(1 << i)];
			}
		}
	}
}
```

## References

https://codeforces.com/blog/entry/45223
