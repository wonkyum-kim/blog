---
title: Zustand persist 분석해보기
date: 2024-04-02
description: persist 어떻게 동작하는가
tags:
  - FE
  - Zustand
---

## 동기 저장소와 비동기 저장소

![](/posts/20240402/persist1.png)

persist middleware는 zustand 상태를 저장소(e.g. localStorage, AsyncStorage, IndexedDB)에 저장할 수 있게 한다.

- 동기 저장소: localStorage
- 비동기 저장소: AsyncStorage, IndexedDB

zustand의 미들웨어는 두 저장소 모두 지원하지만, 비동기 저장소를 사용하는 경우 비용이 든다.

비동기 저장소의 비용에 대해 설명하기 위해서, 하이드레이션이 무엇인지 이해해야한다.

간단히 말해서 하이드레이션은 저장소에 저장된 상태를 가져와서 현재 상태와 병합하는 프로세스다.

persist 미들웨어는 2 종류의 하이드레이션(동기적, 비동기적)을 한다.

- 동기적 하이드레이션: zustand의 스토어는 생성될 때 이미 하이드레이션 된 상태임.
- 비동기적 하이드레이션: zustand의 스토어는 나중에 하이드레이션이 된다.

즉, 비용이란 비동기 동작으로 인한 재하이드레이션(rehydration)을 의미한다.

## persist란

이 글을 읽으려면 [create가 무엇인지](https://blog-gray-omega-81.vercel.app/blog/20231220-Zustand)에 대해 알고 있어야 한다.

`persist`에는 원래 적던 `함수`와 `옵션`을 넣어주면 된다.

아래는 [zustand 문서](https://docs.pmnd.rs/zustand/integrations/persisting-store-data)에 나온 기본 예제다.

```ts
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

export const useBearStore = create(
  persist(
    // 함수
    (set, get) => ({
      bears: 0,
      addABear: () => set({ bears: get().bears + 1 }),
    }),
    // 옵션
    {
      name: 'food-storage',
      storage: createJSONStorage(() => sessonStorage),
    }
  )
);
```

여기서 궁금한 점은 2개다.

1. persist란 무엇인가
2. createJSONStorage란 무엇인가

## persist의 구현

![](/posts/20240402/persist2.png)

`persist`의 구현을 분석해보자.

```ts
// src/middleware/persist.ts
export const persist = persistImpl as unknown as Persist;

const persistImpl: PersistImpl = (config, baseOptions) => {
  if (
    'getStorage' in baseOptions ||
    'serialize' in baseOptions ||
    'deserialize' in baseOptions
  ) {
    if (import.meta.env?.MODE !== 'production') {
      console.warn(
        '[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.'
      );
    }
    return oldImpl(config, baseOptions);
  }
  return newImpl(config, baseOptions);
};
```

단순화 시켜보면,

```ts
export const persist = persistImpl;

function persistImpl(config, baseOptions) {
  return newImpl(config, baseOptions);
}
```

create를 분석했던 것 처럼 zustand는 래퍼 함수를 많이 쓰고 있음을 알 수 있다.

`persistImpl`은 `oldImpl` 또는 `newImpl`을 호출하는데, oldImpl은 deprecated된 것이므로 newImpl만을 살펴보도록 한다.

이전에 함수라고 불렀던 것은 `config`로, 옵션 이라고 불렀던 것은 `baseOptions`으로 생각한다.

즉 persist는 추가적으로 받은 baseOptions를 가지고 무엇을 한 다음, create에 넘겨주는 역할을 한다.

1. ~~persist란 무엇인가~~
2. createJSONStorage란 무엇인가

## newImpl

`newImpl`은 너무 길기 때문에 조금씩 단순화 시켜보면서 진행해보겠다.

```ts
function newImpl(config, baseOptions) {
  return (set, get, api) => {
    let options = {
      storage: createJSONStorage<S>(() => localStorage),
      partialize: (state: S) => state,
      version: 0,
      merge: (persistedState, currentState) => ({
        ...currentState,
        ...persistedState,
      }),
      ...baseOptions,
    };

    // ...

    return stateFromStorage || configResult;
  };
}
```

`options`는 persist에서 전달한 baseOptions를 그대로 사용하되, 값이 없으면 기본 값을 사용한다.

기본 저장소는(storage) `localStorage`이다.

결국 마지막에는, newImpl은 어떤 함수를 반환하는데, 그 함수에서 반환하는 값은 `stateFromStorage || configResult`다.

여기서 또 알아봐야 하는 것이 추가되었다.

1. ~~persist란 무엇인가~~
2. createJSONStorage란 무엇인가
3. stateFromStorage는 무엇인가
4. configResult는 무엇인가

### setItem

state를 가져와서 storage에 저장하는 역할을 한다.

예를 들어 localStorage라고 하자.

![](/posts/20240402/setItem.png)

그리고 api의 setState에서 setItem을 호출하도록 변경한다.

![](/posts/20240402/setItem2.png)

```ts
function newImpl(config, baseOptions) {
  return (set, get, api) => {
    let options = {
      // ...
    };

    let storage = options.storage;

    const setItem = () => {
      const state = options.partialize({ ...get() });
      return storage.setItem(options.name, {
        state,
        version: options.version,
      });
    };

    // api의 setState
    const savedSetState = api.setState;

    // api의 setState와 setItem을 합친다.
    api.setState = (state, replace) => {
      savedSetState(state, replace);
      void setItem();
    };

    // config도 변경
    const configResult = config(
      (...args) => {
        set(...args);
        void setItem();
      },
      get,
      api
    );
  };
}
```

`void setItem()`이 무슨 의미인지 몰라서 찾아보았는데, setItem이 반환하는 값을 쓰지 않고 `undefined`로 하기 위함인 것으로 보인다.

[void 연산자](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/void)

마지막으로 config의 set 부분을 setItem으로 변경해준 `configResult`를 만든다.

1. ~~persist란 무엇인가~~
2. createJSONStorage란 무엇인가
3. stateFromStorage는 무엇인가
4. ~~configResult는 무엇인가~~

### hydrate

![](/posts/20240402/hydrate.png)

`stateFromStorage`는 저장소에 들어있는 상태다.

위에서 설명한 하이드레이션이 어떻게 진행되는지 단순화 시켜 살펴보자.

```ts
function newImpl(config, baseOptions) {
  return (set, get, api) => {
    let options = {
      // ...
    };

    let hasHydrated = false;
    const hydrationListeners = new Set();
    const finishHydrationListeners = new Set();

    // 저장소에 들어있는 상태
    let stateFromStorage;

    // 하이드레이션
    const hydrate = () => {
      // 아직 하이드레이션 되지 않았음
      hasHydrated = false;

      // 하이드레이션을 시작하기 전에 실행하는 콜백함수들
      hydrationListeners.forEach((cb) => cb(get()));

      // 하이드레이션을 마치고 실행하는 콜백함수
      const postRehydrationCallback =
        options.onRehydrateStorage?.(get()) || undefined;

      // 1. 저장소에서 options.name에 해당하는 값을 가져온다. 이 값은 문자열이다.
      // 2. 역직렬화(e.g. JSON.parse())를 사용해서 객체로 만든다.
      // 3. 저장소에서 가져온 값과 zustand의 상태를 합치고 최신 상태를 유지하도록 한다.
      // 5. postRehydrationCallback을 실행한다.
      // 6. hasHydrated = true;
      // 7. finishHydrationListeners에 있는 콜백 함수들을 실행한다.
    };

    // ...

    // 하이드레이션을 실행한다.
    if (!options.skipHydration) {
      hydrate();
    }

    return stateFromStorage || configResult;
  };
}
```

1. ~~persist란 무엇인가~~
2. createJSONStorage란 무엇인가
3. ~~stateFromStorage는 무엇인가~~
4. ~~configResult는 무엇인가~~

## createJSONStorage

이제 `createJSONStorage`를 살펴보자.

createJSONStorage는 persistStorage 객체를 생성하는 함수다.

첫 번째 매개변수로 저장소의 종류를 반환하는 함수를 전달하고, 두 번째 매개변수로 옵션을 전달한다.

이 옵션은 `replacer`과 `reviver`에 대한 것으로 사용하지 않을 것이라면 전달하지 않아도 된다.

[JSON과 메서드](https://ko.javascript.info/json)

```ts
// src/middleware/persist.ts
export function createJSONStorage(
  getStorage: () => StateStorage,
  options?: JsonStorageOptions
) {
  let storage: StateStorage | undefined;
  try {
    storage = getStorage();
  } catch (e) {
    // prevent error if the storage is not defined (e.g. when server side rendering a page)
    return;
  }
  const persistStorage = {
    getItem: (name) => {
      const parse = (str: string | null) => {
        if (str === null) {
          return null;
        }
        return JSON.parse(str, options?.reviver);
      };
      const str = storage.getItem(name) ?? null;
      if (str instanceof Promise) {
        return str.then(parse);
      }
      return parse(str);
    },
    setItem: (name, newValue) =>
      storage.setItem(name, JSON.stringify(newValue, options?.replacer)),
    removeItem: (name) => (storage as StateStorage).removeItem(name),
  };
  return persistStorage;
}
```

- getItem: name에 해당하는 아이템을 가져와서 역직렬화하여 반환한다.
- setItem: name에 해당하는 아이템을 새로운 값으로 직렬화하여 저장한다.
- removeItem: name에 해당하는 아이템을 제거한다.

1. ~~persist란 무엇인가~~
2. ~~createJSONStorage란 무엇인가~~
3. ~~stateFromStorage는 무엇인가~~
4. ~~configResult는 무엇인가~~

## NextJS에서 사용하기

NextJS는 서버사이드 렌더링을 하기 때문에, 다음과 같은 방식으로 사용하면 된다.

먼저 커스텀 훅을 만든다.

```ts
// useStore.ts

const useStore = <T, F>(
  store: (callback: (state: T) => unknown) => unknown,
  callback: (state: T) => F
) => {
  const result = store(callback) as F;
  const [data, setData] = useState<F>();

  useEffect(() => {
    setData(result);
  }, [result]);

  return data;
};

export default useStore;
```

그리고 zustand 스토어는 persist를 사용해 만든다.

```ts
// useBearStore.ts

import { create } from 'zustand';
import { persist } from 'zustand/middleware';

// the store itself does not need any change
export const useBearStore = create(
  persist(
    (set, get) => ({
      bears: 0,
      addABear: () => set({ bears: get().bears + 1 }),
    }),
    {
      name: 'food-storage',
    }
  )
);
```

실제 사용하는 컴포넌트에서는 `useStore`로 스토어를 감싸서 사용한다.

```ts
// yourComponent.tsx

import useStore from './useStore';
import { useBearStore } from './stores/useBearStore';

const bears = useStore(useBearStore, (state) => state.bears);
```

## IndexedDB와 사용하기

localStorage가 아니고 IndexedDB에서 사용하려면, 각 메서드를 직접 정의해주는 것이 필요하다.

```ts
import { create } from 'zustand';
import { persist, createJSONStorage, StateStorage } from 'zustand/middleware';
import { get, set, del } from 'idb-keyval';

// Custom storage object
const storage: StateStorage = {
  getItem: async (name: string): Promise<string | null> => {
    console.log(name, 'has been retrieved');
    return (await get(name)) || null;
  },
  setItem: async (name: string, value: string): Promise<void> => {
    console.log(name, 'with value', value, 'has been saved');
    await set(name, value);
  },
  removeItem: async (name: string): Promise<void> => {
    console.log(name, 'has been deleted');
    await del(name);
  },
};

export const useBoundStore = create(
  persist(
    (set, get) => ({
      bears: 0,
      addABear: () => set({ bears: get().bears + 1 }),
    }),
    {
      name: 'food-storage', // unique name
      storage: createJSONStorage(() => storage),
    }
  )
);
```

하지만, indexedDB를 사용하는 경우 persist는 좋은 선택이 아니라고 생각한다.

내가 persist와 indexedDB를 함께 사용하려고 해보면서 고민해본 생각들을 몇가지 적어보았다.

1. 공식 문서에 `idb-keyval` 라이브러리 사용 예제 밖에 없음
2. `idb-keyval`를 사용하지 않아도 되긴 하지만 이러면 작성해야하는 코드 양이 많아져서 persist를 사용하는 의미가 별로 없음
3. `idb-keyval`을 사용하는 경우 내가 만들고 싶은 객체 저장소(objectStore)를 만들 수 없어보임(확실하지는 않음.)
4. 직렬화와 역직렬화를 사용하여 데이터를 저장하는데, indexedDB에서는 불필요한 과정임.

4번에서 직렬화를 하여 저장소에 저장하는 이유에 대해 생각해보았는데, 아마도 `localStorage`의 키와 값은 반드시 문자열이어야 하기 때문인 것으로 보인다.

[localStorage와 sessionStorage](https://ko.javascript.info/localstorage#ref-43)

하지만 indexedDB의 경우 그냥 객체도 넣어줄 수 있으므로 불필요한 과정이다.

## 내가 indexedDB를 zustand와 함께 사용한 방법

zustand의 설계를 뜯어고쳐서 pr을 하지 않는 이상 그대로 사용하기엔 불편했다.

그리고 어차피 하이드레이션이 문제라면, 그냥 클라이언트 사이드에서 indexedDB에 저장되어 있는 값을 가져오고 zustand에 직접 값을 넣어주면 된다고 생각한다.

일단 zustand의 스토어의 구조를 indexedDB의 objectStore와 동일하게 설계했다.

```ts:calHeatStore.ts
import { create } from 'zustand';

import { Heat } from '@/types';

type State = {
  calHeat: {
    [key: string]: Heat;
  };
};

type Action = {
  addCalHeatItem: (items: { [key: string]: Heat }) => void;
};

export const useCalHeatStore = create<State & Action>()((set) => ({
  calHeat: {},
  addCalHeatItem: (items: { [key: string]: Heat }) =>
    set((state) => ({ calHeat: { ...state.calHeat, ...items } })),
}));
```

그리고 `page.tsx`에서 하이드레이션을 하게 해주는 커스텀 훅을 만들었다.

```tsx:useHydrateCalHeatStore.tsx
import { useEffect } from 'react';

import type { Heat } from '@/types';
import { getAllDataFromIndexedDB } from '@/lib/idb';
import { useCalHeatStore } from '@/app/store/calHeatStore';

export function useHydrateCalHeatStore() {
  const addCalHeatItem = useCalHeatStore((state) => state.addCalHeatItem);

  useEffect(() => {
    const getAllData = async () => {
      // indexedDB에서 모든 데이터를 가져온다.
      const indexedDBData = await getAllDataFromIndexedDB<Heat>('calHeat');

      // zustand에 가져온 데이터를 넣는다. (hydrate)
      const zustandState: { [key: string]: Heat } = {};

      indexedDBData.forEach((item) => {
        zustandState[item.id] = item;
      });

      addCalHeatItem(zustandState);
    };

    getAllData();
  }, [addCalHeatItem]);
}
```

```tsx:page.tsx
'use client';

export function Page() {
  useHydrateCalHeatStore();
  return // ...
}
```

하지만 실제 컴포넌트에서 zustand의 스토어에 값을 추가하거나 삭제하려면, 일일히 indexedDB에도 반영시켜야 한다는 단점이 존재한다.

```ts
const onSubmit = async (formData: FormData) => {
  const data: Heat = {
    //...
  };
  // idb
  await editDataFromIndexedDB<Heat>('calHeat', data, data.id);
  // zustand
  addCalHeatItem({ [data.date]: data });
};
```

이 번거로운 과정을 어떻게 하면 줄일 수 있을까에 대해 고민을 해보았는데 쉽게 결론이 나오지는 않았다.

1. Proxy를 사용? -> 코드 양이 줄어들지는 않고 idb에 접근하는 로직이 잘 동작하지 않는 것 같다.(코드를 잘못짜서 그럴수도...)
2. Zustand의 설계를 뜯어 고치기? -> 자신있게 도전해봤다가 상당히 복잡한 코드에 당황하는 중... 성공한다고 해도 pr이 merge가 안된다면 매우 슬플 것 같음. 멀쩡히 돌아가는 코드의 설계를 뜯어고치는 거라서...

고민이 해결될 때까지 localStorage를 사용할 때만 persist를 사용해 보는 것으로 해야겠다.

## References

- [Zustand](https://github.com/pmndrs/zustand/blob/main/src/middleware/persist.ts)
