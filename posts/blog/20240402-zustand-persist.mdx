---
title: Zustand persist 분석해보기
date: 2024-04-02
description: persist는 어떻게 동작하는가
tags:
  - FE
  - Zustand
---

## 동기 저장소와 비동기 저장소

![](/posts/20240402/persist1.png)

persist middleware는 zustand 상태를 저장소(e.g. localStorage, AsyncStorage, IndexedDB)에 저장할 수 있게 한다.

- 동기 저장소: localStorage
- 비동기 저장소: AsyncStorage, IndexedDB

zustand의 미들웨어는 두 저장소 모두 지원하지만, 비동기 저장소를 사용하는 경우 비용이 든다.

비동기 저장소의 비용에 대해 설명하기 위해서, 하이드레이션이 무엇인지 이해해야한다.

간단히 말해서 하이드레이션은 저장소에 저장된 상태를 가져와서 현재 상태와 병합하는 프로세스다.

persist 미들웨어는 2 종류의 하이드레이션(동기적, 비동기적)을 한다.

- 동기적 하이드레이션: zustand의 스토어는 생성될 때 이미 하이드레이션 된 상태임.
- 비동기적 하이드레이션: zustand의 스토어는 나중에 하이드레이션이 된다.

즉, 비용이란 비동기 동작으로 인한 재하이드레이션(rehydration)을 의미한다.

## persist란

이 글을 읽으려면 [create가 무엇인지](https://blog-gray-omega-81.vercel.app/blog/20231220-Zustand)에 대해 알고 있어야 한다.

`persist`에는 원래 적던 `함수`와 `옵션`을 넣어주면 된다.

아래는 [zustand 문서](https://docs.pmnd.rs/zustand/integrations/persisting-store-data)에 나온 기본 예제다.

```ts
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

export const useBearStore = create(
  persist(
    // 함수
    (set, get) => ({
      bears: 0,
      addABear: () => set({ bears: get().bears + 1 }),
    }),
    // 옵션
    {
      name: 'food-storage',
      storage: createJSONStorage(() => sessonStorage),
    }
  )
);
```

여기서 궁금한 점은 2개다.

1. persist란 무엇인가
2. createJSONStorage란 무엇인가

## persist의 구현

![](/posts/20240402/persist2.png)

`persist`의 구현을 분석해보자.

```ts
// src/middleware/persist.ts
export const persist = persistImpl as unknown as Persist;

const persistImpl: PersistImpl = (config, baseOptions) => {
  if (
    'getStorage' in baseOptions ||
    'serialize' in baseOptions ||
    'deserialize' in baseOptions
  ) {
    if (import.meta.env?.MODE !== 'production') {
      console.warn(
        '[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.'
      );
    }
    return oldImpl(config, baseOptions);
  }
  return newImpl(config, baseOptions);
};
```

단순화 시켜보면,

```ts
export const persist = persistImpl;

function persistImpl(config, baseOptions) {
  return newImpl(config, baseOptions);
}
```

create를 분석했던 것 처럼 zustand는 래퍼 함수를 많이 쓰고 있음을 알 수 있다.

`persistImpl`은 `oldImpl` 또는 `newImpl`을 호출하는데, oldImpl은 deprecated된 것이므로 newImpl만을 살펴보도록 한다.

이전에 함수라고 불렀던 것은 `config`로, 옵션 이라고 불렀던 것은 `baseOptions`으로 생각한다.

즉 persist는 추가적으로 받은 baseOptions를 가지고 무엇을 한 다음, create에 넘겨주는 역할을 한다.

1. ~~persist란 무엇인가~~
2. createJSONStorage란 무엇인가

## newImpl

`newImpl`은 너무 길기 때문에 조금씩 단순화 시켜보면서 진행해보겠다.

```ts
function newImpl(config, baseOptions) {
  return (set, get, api) => {
    let options = {
      storage: createJSONStorage<S>(() => localStorage),
      partialize: (state: S) => state,
      version: 0,
      merge: (persistedState, currentState) => ({
        ...currentState,
        ...persistedState,
      }),
      ...baseOptions,
    };

    // ...

    return stateFromStorage || configResult;
  };
}
```

`options`는 persist에서 전달한 baseOptions를 그대로 사용하되, 값이 없으면 기본 값을 사용한다.

기본 저장소는(storage) `localStorage`이다.

결국 마지막에는, newImpl은 어떤 함수를 반환하는데, 그 함수에서 반환하는 값은 `stateFromStorage || configResult`다.

여기서 또 알아봐야 하는 것이 추가되었다.

1. ~~persist란 무엇인가~~
2. createJSONStorage란 무엇인가
3. stateFromStorage는 무엇인가
4. configResult는 무엇인가

### setItem

state를 가져와서 storage에 저장하는 역할을 한다.

예를 들어 localStorage라고 하자.

![](/posts/20240402/setItem.png)

그리고 api의 setState에서 setItem을 호출하도록 변경한다.

![](/posts/20240402/setItem2.png)

```ts
function newImpl(config, baseOptions) {
  return (set, get, api) => {
    let options = {
      // ...
    };

    let storage = options.storage;

    const setItem = () => {
      const state = options.partialize({ ...get() });
      return storage.setItem(options.name, {
        state,
        version: options.version,
      });
    };

    // api의 setState
    const savedSetState = api.setState;

    // api의 setState와 setItem을 합친다.
    api.setState = (state, replace) => {
      savedSetState(state, replace);
      void setItem();
    };

    // config도 변경
    const configResult = config(
      (...args) => {
        set(...args);
        void setItem();
      },
      get,
      api
    );
  };
}
```

`void setItem()`이 무슨 의미인지 몰라서 찾아보았는데, setItem이 반환하는 값을 쓰지 않고 `undefined`로 하기 위함인 것으로 보인다.

[void 연산자](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/void)

마지막으로 config의 set 부분을 setItem으로 변경해준 `configResult`를 만든다.

1. ~~persist란 무엇인가~~
2. createJSONStorage란 무엇인가
3. stateFromStorage는 무엇인가
4. ~~configResult는 무엇인가~~

### hydrate

![](/posts/20240402/hydrate.png)

`stateFromStorage`는 저장소에 들어있는 상태다.

위에서 설명한 하이드레이션이 어떻게 진행되는지 단순화 시켜 살펴보자.

```ts
function newImpl(config, baseOptions) {
  return (set, get, api) => {
    let options = {
      // ...
    };

    let hasHydrated = false;
    const hydrationListeners = new Set();
    const finishHydrationListeners = new Set();

    // 저장소에 들어있는 상태
    let stateFromStorage;

    // 하이드레이션
    const hydrate = () => {
      // 아직 하이드레이션 되지 않았음
      hasHydrated = false;

      // 하이드레이션을 시작하기 전에 실행하는 콜백함수들
      hydrationListeners.forEach((cb) => cb(get()));

      // 하이드레이션을 마치고 실행하는 콜백함수
      const postRehydrationCallback =
        options.onRehydrateStorage?.(get()) || undefined;

      // 1. 저장소에서 options.name에 해당하는 값을 가져온다. 이 값은 문자열이다.
      // 2. 역직렬화(e.g. JSON.parse())를 사용해서 객체로 만든다.
      // 3. 저장소에서 가져온 값과 zustand의 상태를 합치고 최신 상태를 유지하도록 한다.
      // 5. postRehydrationCallback을 실행한다.
      // 6. hasHydrated = true;
      // 7. finishHydrationListeners에 있는 콜백 함수들을 실행한다.
    };

    // ...

    // 하이드레이션을 실행한다.
    if (!options.skipHydration) {
      hydrate();
    }

    return stateFromStorage || configResult;
  };
}
```

1. ~~persist란 무엇인가~~
2. createJSONStorage란 무엇인가
3. ~~stateFromStorage는 무엇인가~~
4. ~~configResult는 무엇인가~~

## createJSONStorage

이제 `createJSONStorage`를 살펴보자.

createJSONStorage는 persistStorage 객체를 생성하는 함수다.

첫 번째 매개변수로 저장소의 종류를 반환하는 함수를 전달하고, 두 번째 매개변수로 옵션을 전달한다.

이 옵션은 `replacer`과 `reviver`에 대한 것으로 사용하지 않을 것이라면 전달하지 않아도 된다.

[JSON과 메서드](https://ko.javascript.info/json)

```ts
// src/middleware/persist.ts
export function createJSONStorage(
  getStorage: () => StateStorage,
  options?: JsonStorageOptions
) {
  let storage: StateStorage | undefined;
  try {
    storage = getStorage();
  } catch (e) {
    // prevent error if the storage is not defined (e.g. when server side rendering a page)
    return;
  }
  const persistStorage = {
    getItem: (name) => {
      const parse = (str: string | null) => {
        if (str === null) {
          return null;
        }
        return JSON.parse(str, options?.reviver);
      };
      const str = storage.getItem(name) ?? null;
      if (str instanceof Promise) {
        return str.then(parse);
      }
      return parse(str);
    },
    setItem: (name, newValue) =>
      storage.setItem(name, JSON.stringify(newValue, options?.replacer)),
    removeItem: (name) => (storage as StateStorage).removeItem(name),
  };
  return persistStorage;
}
```

- getItem: name에 해당하는 아이템을 가져와서 역직렬화하여 반환한다.
- setItem: name에 해당하는 아이템을 새로운 값으로 직렬화하여 저장한다.
- removeItem: name에 해당하는 아이템을 제거한다.

1. ~~persist란 무엇인가~~
2. ~~createJSONStorage란 무엇인가~~
3. ~~stateFromStorage는 무엇인가~~
4. ~~configResult는 무엇인가~~

## NextJS에서 사용하기

NextJS는 서버사이드 렌더링을 하기 때문에, 다음과 같은 방식으로 사용하면 된다.

먼저 커스텀 훅을 만든다.

```ts
// useStore.ts

const useStore = <T, F>(
  store: (callback: (state: T) => unknown) => unknown,
  callback: (state: T) => F
) => {
  const result = store(callback) as F;
  const [data, setData] = useState<F>();

  useEffect(() => {
    setData(result);
  }, [result]);

  return data;
};

export default useStore;
```

그리고 zustand 스토어는 persist를 사용해 만든다.

```ts
// useBearStore.ts

import { create } from 'zustand';
import { persist } from 'zustand/middleware';

// the store itself does not need any change
export const useBearStore = create(
  persist(
    (set, get) => ({
      bears: 0,
      addABear: () => set({ bears: get().bears + 1 }),
    }),
    {
      name: 'food-storage',
    }
  )
);
```

실제 사용하는 컴포넌트에서는 `useStore`로 스토어를 감싸서 사용한다.

```ts
// yourComponent.tsx

import useStore from './useStore';
import { useBearStore } from './stores/useBearStore';

const bears = useStore(useBearStore, (state) => state.bears);
```

## IndexedDB와 사용하기

localStorage가 아니고 IndexedDB에서 사용하려면, 각 메서드를 직접 정의해주는 것이 필요하다.

```ts
import { create } from 'zustand';
import { persist, createJSONStorage, StateStorage } from 'zustand/middleware';
import { get, set, del } from 'idb-keyval';

// Custom storage object
const storage: StateStorage = {
  getItem: async (name: string): Promise<string | null> => {
    console.log(name, 'has been retrieved');
    return (await get(name)) || null;
  },
  setItem: async (name: string, value: string): Promise<void> => {
    console.log(name, 'with value', value, 'has been saved');
    await set(name, value);
  },
  removeItem: async (name: string): Promise<void> => {
    console.log(name, 'has been deleted');
    await del(name);
  },
};

export const useBoundStore = create(
  persist(
    (set, get) => ({
      bears: 0,
      addABear: () => set({ bears: get().bears + 1 }),
    }),
    {
      name: 'food-storage', // unique name
      storage: createJSONStorage(() => storage),
    }
  )
);
```

하지만, indexedDB를 사용하는 경우 persist는 좋은 선택이 아니라고 생각한다.

내가 persist와 indexedDB를 함께 사용하려고 해보면서 고민해본 생각들을 몇가지 적어보았다.

1. 공식 문서에 `idb-keyval` 라이브러리 사용 예제 밖에 없음
2. `idb-keyval`를 사용하지 않아도 되긴 하지만 이러면 작성해야하는 코드 양이 많아져서 persist를 사용하는 의미가 별로 없음
3. `idb-keyval`을 사용하는 경우 내가 만들고 싶은 객체 저장소(objectStore)를 만들 수 없어보임(확실하지는 않음.)
4. 직렬화와 역직렬화를 사용하여 데이터를 저장하는데, indexedDB에서는 불필요한 과정임.

4번에서 직렬화를 하여 저장소에 저장하는 이유에 대해 생각해보았는데, 아마도 `localStorage`의 키와 값은 반드시 문자열이어야 하기 때문인 것으로 보인다.

[localStorage와 sessionStorage](https://ko.javascript.info/localstorage#ref-43)

하지만 indexedDB의 경우 그냥 객체도 넣어줄 수 있으므로 불필요한 과정이다.

## 내가 indexedDB를 zustand와 함께 사용한 방법

고민 끝에 persist를 사용하지 않는 해결책을 찾았다.

zustand의 설계를 고치는 것은 처음부터 무리였던 것이었고...

바닐라 자바스크립트에서 재렌더링을 유발하기 위해 `subscribe`를 사용했던 것이 생각나서 적용해보았더니 해결되었다.

일단 indexedDB를 어떻게 사용해야하는지에 대해 살펴보아야 한다.

[이것에 대한 글은 블로그에 따로 작성했으니 참고한다.](https://blog-gray-omega-81.vercel.app/blog/20240404-indexedDB)

스토어에 하이드레이션을 하는 함수와, setState가 호출될 때마다 실행되는 콜백 함수를 작성하였다.

이후 일반적인 zustand의 사용법과 똑같이 사용하면 된다.

```ts
import { create } from 'zustand';

import { editDataFromIndexedDB, addDataToIndexedDB } from '@/lib/idb';

export type Bear = {
  id: string;
  weight: number;
  food: string;
};

type State = {
  bear: {
    [key: string]: Bear;
  };
};

type Action = {
  addBear: (items: { [key: string]: Bear }) => void;
};

const dbName = 'bear-db';
const objectStoreName = 'bear-store';
const version = 1;

export const useBearStore = create<State & Action>()((set) => ({
  bear: {},
  addBear: (items: { [key: string]: Bear }) =>
    set((state) => ({ bear: { ...state.bear, ...items } })),
}));

// Hydration
async function hydrate() {
  if (!globalThis.indexedDB) return;

  const indexedDBData = await getAllDataFromIndexedDB<Bear>(
    dbName,
    objectStoreName,
    version
  );

  const zustandState: { [key: string]: Bear } = {};

  indexedDBData.forEach((item) => {
    zustandState[item.id] = item;
  });

  useBearStore.setState((state) => ({
    bear: { ...state.bear, ...zustandState },
  }));
}

hydrate();

// This callback function runs every time you store data.
useCalHeatStore.subscribe(async (state, prevState) => {
  const stateKeys = Object.keys(state.bear);
  const prevStateKeys = Object.keys(prevState.bear);

  // Do not run for hydration.
  if (prevStateKeys.length === 0) return;

  // Find newly added or changed items.
  for (let i = 0; i < stateKeys.length; ++i) {
    const key = stateKeys[i];
    const value = state.calHeat[key];
    // New item
    if (!prevStateKeys.includes(key)) {
      await addDataToIndexedDB<Bear>(dbName, objectStoreName, version, value);
      break;
    }
    // Changed item
    const prevValue = prevState.calHeat[key];
    if (JSON.stringify(value) !== JSON.stringify(prevValue)) {
      await editDataFromIndexedDB<Bear>(
        dbName,
        objectStoreName,
        version,
        value
      );
      break;
    }
  }
});
```

## References

- [Zustand](https://github.com/pmndrs/zustand/blob/main/src/middleware/persist.ts)
