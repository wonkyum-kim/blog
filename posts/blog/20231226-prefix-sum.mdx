---
title: 누적 합(Prefix sum)
date: 2023-12-26
description: 누적 합을 구하는 여러가지 방법들
tags:
  - Algorithm
---

## 정적인 누적 합

배열의 $i$번째 원소부터 $j$번째 원소까지의 합을 구하기 위해서는 단순히 for 문 한 번을 사용해 구할 수 있습니다.

하지만 배열의 원소가 변하지 않고, 이런 쿼리가 여러 번 계속될 경우 `누적 합`을 사용해 $O(1)$ 시간에 빠르게 구할 수 있습니다.

누적 합의 아이디어는 이전까지의 모든 원소의 합을 저장해두는 것입니다.

### 1차원 누적 합

1차원 누적 합은 원래 배열 `v`과 이전까지의 모든 원소의 합을 저장하는 배열 `sum`을 관리하면 됩니다.

a부터 b까지의 모든 원소의 합은 1부터 b까지의 모든 원소의 합에서 1부터 a - 1까지의 모든 원소의 합을 빼면 됩니다.

(계산의 편의를 위해 index가 1부터 시작합니다.)

```cpp
vector<int> sum(n + 1);

for (int i = 1; i <= n; ++i) {
	sum[i] = sum[i - 1] + v[i];
}

// a번째 원소부터 b번째 원소까지의 합
int ans = sum[b] - sum[a - 1];
```

### 2차원 누적 합

2차원 누적 합은 1차원 누적합과 크게 다르지 않습니다.

전체에서 겹치는 부분을 빼주고 현재 원소를 더해주면 됩니다.

```cpp
vector<vector<int>> sum(n + 1, vector<int>(m + 1));

for (int i = 1; i <= n; ++i) {
	for (int j = 1; j <= m; ++j) {
		sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + v[i][j];
	}
}

// (a1, b1)에서 (a2, b2)까지의 합
int ans = sum[a2][b2] - sum[a2][b1 - 1] - sum[a1 - 1][b2] + sum[a1 - 1][b1 - 1];
```

## 동적인 누적 합 (imos)

주어진 구간에 속한 모든 원소 또는 특정 원소 하나를 업데이트하고 누적 합을 구하기 위해서는 여러 가지 방법이 존재하지만, 간단한 `imos` 방법에 대해서 소개합니다.

### 1차원 누적 합

구간 (a) 부터 (b) 까지 k를 더한다고 했을 때, `sum[a]`에 k를 더하고, `sum[b + 1]`에 -k를 더합니다.

그리고 누적 합을 구해주면 됩니다.

```cpp
// 초기 상태
[0,0,0,0,0,0]

// [0,4]에 1만큼 더하고 싶다면 [0]에 1, [5]에 -1을 더함
[1,0,0,0,0,-1]

// 누적 합을 구함
[1,1,1,1,1,0]
```

신기하게도 원하는 대로 구간에 원하는 만큼의 값이 더해진 것을 확인할 수 있습니다.

### 2차원 누적 합

2차원도 다르지 않습니다.

구간 (a, b)에서 (c, d)까지 k만큼 더한다고 했을 때, 다음과 같이 진행합니다.

- `sum[a][b] += k`
- `sum[a][c + 1] -= k`
- `sum[a + 1][b] -= k`
- `sum[a + 1][c + 1] += k`

그리고 누적 합을 행과 열 순서로 각각 진행합니다.

```cpp
// 아래로
for (int i = 1; i < n; ++i) {
	for (int j = 0; j < m; ++j) {
		sum[i][j] += sum[i - 1][j];
	}
}

// 옆으로
for (int i = 0; i < n; ++i) {
	for (int j = 1; j < m; ++j) {
		sum[i][j] += sum[i][j - 1];
	}
}
```

### 다른 방법들

imos는 꽤 괜찮은 방법이지만, 경우에 따라 다른 방법들도 많이 사용됩니다.

e.g) 펜윅 트리, 세그먼트 트리

다음에는 이 방법들에 대해 포스팅 해보도록 하겠습니다.

## References

https://codeforces.com/blog/entry/86420
