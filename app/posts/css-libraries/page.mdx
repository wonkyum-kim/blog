import { CodeSelector } from '@/components/code-selector.tsx'
import { ToolTip } from '@/components/tooltip.tsx'
import { Title } from '@/components/title'
import { TOC } from '@/components/toc'
import { getHeadingsBySlug } from '@/lib/mdx'

<Title slug={'css-libraries'} />

<TOC headings={getHeadingsBySlug('css-libraries')} />

## 전처리(preprocessing)

css 문법을 변형하여 작성한 파일을 전처리하여 css 파일을 생성하는 방법.

기본적으로 nesting, mixin 기능을 지원하는 css라고 생각하면 된다.

- [scss](https://sass-lang.com/guide/): sass와의 차이점은 중괄호와 세미콜론의 여부
- [less](https://lesscss.org/functions/): 조건문과 함수등 많은 기능을 지원하고 있다.
- [stylus](https://stylus-lang.com/docs/): 중괄호, 콜론, 세미콜론까지 모두 옵셔널로 설정되어 있다.

각 [전처리 라이브러리들을 비교한 글](https://webdesign.tutsplus.com/sass-vs-less-vs-stylus-preprocessor-shootout--net-24320t)

## CSS module

`.module.css`를 사용하면, css class 이름을 고유한 값으로 자동 생성해주기 때문에 충돌을 방지할 수 있다.

css module 또한 전처리 방식을 사용한 것.

생성된 css는 webpack의 css-loader를 사용해서 js에서 불러올 수 있게 된다.

## CSS-in-JS

크게 runtime, zero-runtime, near-zero-runtime으로 구분된다.

구분과 상관 없이, 기본적으로 자바스크립트 또는 타입스크립트에서 코드를 작성하기 때문에 2가지 방법이 사용된다.

- [template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
- object

template literals을 사용하면 얻는 장점은 별도의 러닝 커브가 필요하지 않고, kebab-case를 사용하기 때문에 기존 css 코드를 그대로 가져올 수 있다.

object를 사용하는 방법은 camelCase 또는 PascalCase를 사용하기 때문에 기존 코드를 그대로 가져올 수 없고, 러닝 커브도 존재한다.

타입스크립트를 사용한다면, type-safety 와 autocomplete 기능을 얻을 수 있다.

### runtime

자바스크립트에서 runtime에 필요한 CSS를 동적으로 만드는 방식이다.

[`CSSStyleSheet.insertRule()`](https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule)을 사용해서 CSSOM에 추가한다.

css 파일을 생성하지 않기 때문에 webpack의 css-loader가 필요하지 않다.

런타임에서 동적으로 스타일을 생성하기 때문에 자주 변경된다면 오버헤드가 발생할 수 있다.

- styled-components
- emotion

### zero-runtime

런타임에 css를 생성하는 것이 아니라 빌드 타임에 번들러가 정적인 css를 생성한다.

따라서 번들러의 추가적인 설정이 반드시 필요하다.

css가 번들러를 사용하게 되면서 사용하지 않는 코드를 쳐내는 것이 가능해졌다.

- vanilla-extract
- linaria: 문법은 styled-components와 거의 똑같은데, build time에 css를 생성한다.

### near-zero-runtime

runtime에 불필요한 prop 보간을 피하도록 만들어졌다.

이게 무슨 의미냐면, build time에 미리 스타일을 다 정의해두고, runtime에 해당 스타일을 선택하여 적용시킨다는 것이다.

- stitches

## Atomic CSS

near-zero-runtime과 비슷한 개념이지만, 거의 모든 스타일이 라이브러리에서 미리 정의되어 있다는 것이 차이점이다.

많은 스타일이 미리 정의되어 있지만 사용하지 않는 스타일은 빌드 시에 포함되지 않으므로 걱정하지 않아도 된다.

tailwind의 경우 JIT 모드도 지원하기 때문에 런타임에 스타일을 추가할 수 있다.

- tailwind

## References

- [CSS-in-JS, 무엇이 다른가요?](https://so-so.dev/web/css-in-js-whats-the-defference/#critical-css%EC%99%80-css-in-js)
