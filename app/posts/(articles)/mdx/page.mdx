import { CodeSelector } from '@/components/code-selector.tsx'
import { ToolTip } from '@/components/tooltip.tsx'
import { Title } from '@/components/title'
import { TOC } from '@/components/toc'
import { getHeadingsBySlug } from '@/lib/mdx'

<Title slug={'mdx'} />

<TOC headings={getHeadingsBySlug('mdx')} />

## @next/mdx

`MDX`는 markdown에 직접 JSX를 작성할 수 있도록 해준다.

Next.js에서는 MDX를 렌더링 할 수 있도록 `@next/mdx` 패키지를 제공하고 있다.

<CodeSelector names={['shell']} desc='nextmdx' />

```shell
npm install @next/mdx @mdx-js/loader @mdx-js/react @types/mdx
```

그리고 애플리케이션의 루트 경로에 `mdx-components.tsx`를 작성해주고 `next.config.mjs`를 업데이트 해준다.

<CodeSelector names={['mdx-components.tsx', 'next.config.mjs']} desc='mdxsettings' />

```tsx showLineNumbers
import type { MDXComponents } from 'mdx/types'

export function useMDXComponents(components: MDXComponents): MDXComponents {
  return {
    ...components,
  }
}
```

```js {10, 19, 20} showLineNumbers
import remarkGfm from 'remark-gfm'
import createMDX from '@next/mdx'
import rehypePrism from 'rehype-prism-plus'
import rehypeSlug from 'rehype-slug'

/** @type {import('next').NextConfig} */
const nextConfig = {
  pageExtensions: ['js', 'jsx', 'mdx', 'ts', 'tsx'],
  experimental: {
    outputFileTracingIncludes: {
      '/app/posts': ['./app/posts/**/*'],
    },
  },
}

const withMDX = createMDX({
  extension: /\.mdx?$/,
  options: {
    remarkPlugins: [remarkGfm],
    rehypePlugins: [rehypePrism, rehypeSlug],
  },
})

export default withMDX(nextConfig)
```

<ToolTip
  name='mdxsettings'
  codeIndex='1'
  content={{
    '10': 'outputFileTracingIncludes 옵션은 vercel에 배포 시 로컬 파일을 찾기 위해서 설정한다.',
    '19': 'remark-gfm은 GitHub 스타일의 마크다운을 사용할 수 있도록 해주는 플러그인이다.',
    '20': 'rehype-prism-plus은 코드 블럭 스타일링을 도와주고,\n  rehype-slug은 헤더 태그에 id를 부여한다.',
  }}
/>

## page.mdx

mdx 파일의 이름은 반드시 `page.mdx`이어야 하며, Next.js에서 route를 정의하는 방식대로 배치하면 된다.

`/posts/hello`에 접속하면 아래 파일이 보여진다.

<CodeSelector names={['app/posts/hello/page.mdx']} desc='hello' />

```md showLineNumbers
import { MyComponent } from '...'

## Hello

world!

<MyComponent />
```

mdx에서는 직접 작성한 컴포넌트도 불러올 수 있다.

## Frontmatter

`@next/mdx`의 단점은 frontmatter를 사용할 수 없다는 것이다.

frontmatter를 사용하기 위해서 `remark-frontamtter`, `remark-mdx-frontmatter`, `gray-matter` 와 같은 플러그인들을 설치해 볼 수 있지만

이 경우 `page.mdx`에 frontmatter를 작성하면 실제 화면에 frontmatter가 같이 보여지는 참사가 일어난다.

또 다른 방법으로는 `next-mdx-remote`를 사용해볼 수 있다.

mdx에 frontmatter를 작성할 수 있고, 실제 화면에는 출력이 되지 않았지만 직접 작성한 컴포넌트를 mdx에 넣으려면 해당 컴포넌트를 `<MDXRemote />`의 props로 넘겨주어야 한다.

이 방법은 컴포넌트를 일일히 props로 넘겨줘야 하는 귀찮은 점이 존재한다.

`@next/mdx`에서 frontmatter를 사용하고 싶다면, 그냥 어딘가에 따로 작성하는 것이 가장 마음이 편하다.

<CodeSelector names={['data/index.ts']} desc='frontmatter' />

```ts showLineNumbers
export const frontmatter = {
  slug1: {
    title: 'title1',
    createdAt: '2024-05-06',
  },
  slug2: {
    title: 'title2',
    createdAt: '2024-06-14',
  },
} as const
```

이제 기본적인 준비는 다 끝났다.

추가적으로 기호에 맞게 TOC와 rehype, remark 플러그인, 툴팁과 같은 것들을 추가해주면 멋진 블로그를 만들 수 있다.

## References

- [Markdown and MDX](https://nextjs.org/docs/app/building-your-application/configuring/mdx)
