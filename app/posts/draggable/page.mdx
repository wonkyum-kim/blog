import { Draggable } from '@/components/draggable/draggable.tsx'
import { InfiniteScroll } from '@/components/css-only/infinite-scroll'
import { CodeSelector } from '@/components/code-selector.tsx'
import { Title } from '@/components/title'
import { TOC } from '@/components/toc'
import { getHeadingsBySlug } from '@/lib/mdx'

<Title slug={'draggable'} />

<TOC headings={getHeadingsBySlug('draggable')} />

<Draggable />

## Pointer 이벤트

자바스크립트에는 기본적으로 [drag 이벤트](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/drag_event)가 존재한다.

하지만 이것은 특정 영역에서 드래그하는 것을 막지 못하고 수평이나 수직으로 드래그 하는 것을 막을 수 도 없다.

그래서 drag 이벤트는 사용하지 않고, [pointer 이벤트](https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events)를 사용한다.

`mouse event`는 모바일 환경에서 터치를 지원하지 않기 때문에 사용할 수 없다.

`touch event`가 존재하지만, pointer 이벤트가 더 상위호환이므로 사용할 이유가 없다.

즉, mouse든 touch든 pointer 이벤트로 전부 해결이 가능하다.

pointer 이벤트는 mouse 이벤트와 사용법이 동일하다.

예를 들어 `onMouseDown`을 `onPointerDown`으로 이름만 바꿔주면 된다.

작동 원리는 다음과 같다.

- pointerdown 이벤트에서 현재 클릭한 지점을 구한다.
- pointermove 이벤트에서 현재 이동한 거리를 구한다.
- 이동한 거리만큼 css transform: translate()를 적용한다.
- pointerup 이벤트에서 지금까지 얼만큼 이동했는지 기록한다.

## pointercancel

본격적인 코드를 작성하기 전에, `pointercancel` 이벤트에 대해 알아야한다.

브라우저는 터치 디바이스에서 드래그 앤 드롭과 같은 터치 액션이 발생하면, 중간에 pointercancel 이벤트를 발생시켜 가로채는 황당한 일이 발생한다.

따라서 사용자는 원하는 대로 드래그를 할 수 없게 된다.

이를 막으려면, css의 `touch-action`을 none으로 설정해야 한다.

<CodeSelector names={['draggable.module.css']} desc='draggablecss' />

```css {17} showLineNumbers
.container {
  width: 100%;
  height: 200px;
  background-color: antiquewhite;
  margin-top: 100px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 5px;
}

.item {
  width: 100px;
  height: 100px;
  background-color: white;
  user-select: none;
  touch-action: none; /* 브라우저가 모든 터치 이벤트를 무시하도록 설정 */
  cursor: grab;
  border-radius: 5px;
}
```

## 이벤트 핸들러

이제 이벤트 핸들러를 작성해보자.

<CodeSelector names={['draggable.tsx']} desc='pointerEvent' />

```tsx {3-4, 16-17, 20-21, 10, 30-31, 26} showLineNumbers
const pointerDownHandler: PointerEventHandler<HTMLDivElement> = (event) => {
  // 처음 클릭한 곳의 좌표
  const initX = event.clientX
  const initY = event.clientY

  let deltaX = 0
  let deltaY = 0

  // 중심(0,0)에서 얼마만큼 translate 할 수 있는지
  const [minX, maxX, minY, maxY] = getBoundary(10, 10)

  const pointerMoveHandler = (event: PointerEvent) => {
    if (!dragItemRef.current) return

    // 얼만큼 움직였는지
    deltaX = event.clientX - initX
    deltaY = event.clientY - initY

    // container의 범위 안에서 drag하도록 조정
    const tx = inBound(prevTranslate.current.x + deltaX, minX, maxX)
    const ty = inBound(prevTranslate.current.y + deltaY, minY, maxY)

    // 하드웨어 가속을 위해 translateZ 설정
    dragItemRef.current.style.setProperty(
      'transform',
      `translateX(${tx}px) translateY(${ty}px) translateZ(${0}px)`
    )
  }
  const pointerUpHandler = () => {
    prevTranslate.current.x += deltaX
    prevTranslate.current.y += deltaY
    document.removeEventListener('pointermove', pointerMoveHandler)
  }

  // passive: true로 설정하여 브라우저에게 preventDefault()를 호출하지 않겠다는 것을 알려준다.
  // https://ko.javascript.info/default-browser-action#ref-462
  document.addEventListener('pointermove', pointerMoveHandler, { passive: true })
  // once: true로 설정하여 pointerup 이벤트가 실행 후 제거되도록 한다.
  document.addEventListener('pointerup', pointerUpHandler, { once: true })
}
```

initX와 initY에 처음으로 클릭한 곳의 좌표를 저장한다.

deltaX와 deltaY는 initX와 initY로 부터 현재 좌표가 얼만큼 떨어져 있는지를 계산한다.

`getBoundary` 함수를 살펴보자.

이 함수는 container의 중심 (0, 0)에서 얼만큼 translate를 적용할 수 있을지 구한다.

즉, item은 x방향으로 minX ~ maxX 사이에서만 이동할 수 있다.

<CodeSelector names={['draggable.tsx']} desc='getBoundary' />

```tsx showLineNumbers
const getBoundary = (paddingX: number, paddingY: number) => {
  if (!dragContainerRef.current || !dragItemRef.current) return [-1, -1, -1, -1]

  const { width: dragAreaWidth, height: dragAreaHeight } =
    dragContainerRef.current.getBoundingClientRect()

  const { width: dragItemWidth, height: dragItemHeight } =
    dragItemRef.current.getBoundingClientRect()

  // container의 너비 절반 - item 너비 절반 - container의 paddingX
  const maxX = Math.floor(dragAreaWidth / 2 - dragItemWidth / 2 - paddingX)
  const minX = -maxX

  // container의 높이 절반 - item 높이 절반 - container의 paddingY
  const maxY = Math.floor(dragAreaHeight / 2 - dragItemHeight / 2 - paddingY)
  const minY = -maxY
  return [minX, maxX, minY, maxY]
}
```

`inBound` 함수는 translate 범위가 한계를 넘어가지 않도록 설정해준다.

`pointerUpHandler`에서 최종적으로 얼만큼 translate 했는지 기록해주면 마무리된다.

## 전체 코드

<CodeSelector names={['draggable.tsx']} desc='final' />

```tsx
'use client'

import styles from './draggable.module.css'
import { PointerEventHandler, useRef } from 'react'

export function Draggable() {
  const prevTranslate = useRef<{ x: number; y: number }>({ x: 0, y: 0 })
  const dragContainerRef = useRef<HTMLDivElement>(null)
  const dragItemRef = useRef<HTMLDivElement>(null)

  const inBound = (x: number, min: number, max: number) => {
    if (min > x) return min
    if (max < x) return max
    return x
  }

  const getBoundary = (paddingX: number, paddingY: number) => {
    if (!dragContainerRef.current || !dragItemRef.current) return [-1, -1, -1, -1]

    const { width: dragAreaWidth, height: dragAreaHeight } =
      dragContainerRef.current.getBoundingClientRect()

    const { width: dragItemWidth, height: dragItemHeight } =
      dragItemRef.current.getBoundingClientRect()

    const maxX = Math.floor(dragAreaWidth / 2 - dragItemWidth / 2 - paddingX)
    const minX = -maxX

    const maxY = Math.floor(dragAreaHeight / 2 - dragItemHeight / 2 - paddingY)
    const minY = -maxY
    return [minX, maxX, minY, maxY]
  }

  const pointerDownHandler: PointerEventHandler<HTMLDivElement> = (event) => {
    const initX = event.clientX
    const initY = event.clientY
    let deltaX = 0
    let deltaY = 0

    const [minX, maxX, minY, maxY] = getBoundary(10, 10)

    const pointerMoveHandler = (event: PointerEvent) => {
      if (!dragItemRef.current) return

      deltaX = event.clientX - initX
      deltaY = event.clientY - initY

      const tx = inBound(prevTranslate.current.x + deltaX, minX, maxX)
      const ty = inBound(prevTranslate.current.y + deltaY, minY, maxY)

      dragItemRef.current.style.setProperty(
        'transform',
        `translateX(${tx}px) translateY(${ty}px) translateZ(${0}px)`
      )
    }
    const pointerUpHandler = () => {
      prevTranslate.current.x += deltaX
      prevTranslate.current.y += deltaY
      document.removeEventListener('pointermove', pointerMoveHandler)
    }

    document.addEventListener('pointermove', pointerMoveHandler, { passive: true })
    document.addEventListener('pointerup', pointerUpHandler, { once: true })
  }

  return (
    <div className={styles.container} ref={dragContainerRef}>
      <div className={styles.item} onPointerDown={pointerDownHandler} ref={dragItemRef} />
    </div>
  )
}
```

## References

- [드래그 앤 드롭과 마우스 이벤트](https://ko.javascript.info/mouse-drag-and-drop)
- [Pointer events](https://ko.javascript.info/pointer-events)
- [Drag 이벤트 뽀개기](https://bepyan.github.io/blog/dnd-master/1-drag-event)
