---
title: Rollup을 사용하여 ESM과 CJS 모두 지원하는 라이브러리 만들기
date: 2024-05-06
description: Rollup의 사용 방법과 설정 방법에 대한 정리
tags:
  - Rollup
---

import { CodeSelector } from '@/components/code-selector.tsx'

## 프로젝트 구성과 목표

현재 작업할 프로젝트의 구성과 목표는 아래와 같이 설정한다.

- 타입스크립트를 사용하여 코드를 작성한다.
- 기본적으로 사용할 모듈 시스템은 ESM이며, CJS를 사용하는 코드를 작성하지는 않지만 지원할 것이다.
- Babel을 사용하여 트랜스파일링을 할 것이다.
- Rollup을 사용해 번들링할 것이다.

## 번들링

번들링이란, 여러 코드와 프로그램들을 묶는 행위를 의미한다.

이와 같은 행위를 하는 이유는, 네트워크 상에서 여러 파일을 다운로드 받는 것 보다 하나로 합쳐진 파일을 받는 것이 더 나을 수 있기도 하고

번들링 하는 과정에서 원본 코드보다 용량도 줄이고, 코드의 로딩 속도와 실행 속도도 높일 수 있기 때문이다.

번들링을 하는 과정에서 등장하는 것이 tree-shaking이다.

트리 쉐이킹은 살아있는 코드만을 포함시키는 것을 의미한다.

즉, 쓰이지 않는 코드를 제거하여 용량을 줄이는 역할을 한다.

그리고 함께 등장하는 것이 minification이다.

개발자가 작성한 코드는 사람이 알아보기 쉽게 작성되어 있지만, 컴퓨터 입장에서는 전혀 상관 없으므로 알아볼 수 없을 정도로 최대한 코드를 줄이는 작업을 진행한다.

## package.json

package.json에서 필요한 옵션은 아래와 같다.

<CodeSelector codes={['package.json']} x='package' />

```json
// package.json
{
  "type": "module",
  "scripts": {
    "build": "rm -rf dist/* && tsc && rollup -c"
  },
  "exports": {
      ".": {
        "require": "./dist/cjs/index.cjs",
        "import": "./dist/esm/index.js",
        "types": "./dist/index.d.ts"
      }
  }
  "browserslist": "last 2 versions, not dead, > 0.25%"
}
```

현재 프로젝트의 모듈 시스템을 ESM으로 설정하기 위해서 `"type": "module"`를 사용한다.

`npm run build`를 사용하면, 이전 빌드 출력 결과물을 지우고, 번들링한다.

좀 더 설명하면, tsc는 각 파일에 해당하는 `.d.ts` 파일들을 `dist` 디렉터리에 생성하고, rollup은 `dist/esm`과 `dist/cjs`에 각각의 자바스크립트 파일을 생성한다.

`browserslist`에 Babel에서 지원할 브라우저를 명시한다.

package.json에 `exports` 필드를 사용하여 실제 filesystem 상의 위치와 다른 모듈 지정자를 사용할 수 있게 된다.

이에 대해서는 이 글의 마지막 부분과 [toss tech](https://toss.tech/article/commonjs-esm-exports-field)의 글을 참조하라.

여기서 간단히 설명하면 아래와 같은 규칙이 적용된다.

1. "type": "module"이 적용된 경우
   - .js는 .mjs와 같으며, ES 모듈 시스템을 적용한 코드를 의미한다.
   - .cjs는 CJS 모듈 시스템을 적용한 코드를 의미한다.
2. "type": "module"이 없는 경우
   - .js는 .cjs와 같으며, CJS 모듈 시스템을 적용한 코드를 의미한다.
   - .mjs는 ES 모듈 시스템을 적용한 코드를 의미한다.

현재 이 프로젝트는 1번의 경우에 해당한다.

## tsconfig.json

tsconfig.json에서 필요한 옵션은 아래와 같다.

<CodeSelector codes={['tsconfig.json']} x='tsconfig' />

```json
{
  "compilerOptions": {
    "module": "esnext",
    "moduleResolution": "bundler",
    "declaration": true,
    "emitDeclarationOnly": true,
    "outDir": "dist",
    "esModuleInterop": true
  },
  "include": ["src/**/*", "tests/**/*"]
}
```

module과 moduleResolution은 esnext와 bundler를 사용한다.

module은 컴파일되어 나온 자바스크립트가 사용할 모듈 시스템을 지정하는 옵션이다.

moduleResolution은 타입스크립트가 모듈 지정자(import나 require 뒤에 건내주는 문자열)를 디스크에 있는 파일에서 찾아내는 알고리즘을 지정하는 옵션이다.

moduleResolution: bundler를 사용하는 이유는, tsc가 아니라 번들러가 파일들을 찾기 때문이다.

bundler로 설정했을 때의 추가적으로 얻는 장점은 느슨한 import를 사용할 수 있다는 것이다.

예를 들어 상대 경로에 있는 파일들을 import 할 때, 파일의 확장자를 적지 않아도 된다.

<CodeSelector codes={['exmaple.ts']} x='foo' />

```ts
import { foo } from './foo'
```

moduleResolution: bundler를 사용했다면 [반드시 module: esnext를 함께 사용해야 한다.](https://www.typescriptlang.org/docs/handbook/modules/reference.html#bundler)

현재 프로젝트는 ESM이기 때문에 CJS 모듈 시스템을 사용하는 외부 라이브러리를 불러올 경우 문제가 발생할 수도 있다.

따라서 esModuleInterop을 true로 설정해서 생길수도 있는 문제를 피할 수 있다.

## babel.config.js

`ECMAScript2015+`로 작성한 코드를 모든 브라우저에서 작동하도록 변환시켜 주는 것을 트랜스파일한다고 표현한다.

`Babel`을 사용하면 자바스크립트 코드를 트랜스파일 할 수 있다.

바벨 그 자체로 실행하는 것은 아무런 변화가 없기 때문에, 플러그인 또는 프리셋을 같이 설치해야한다.

보통은 플러그인이 되게 많기 때문에 여러 플러그인이 합쳐진 프리셋을 사용한다.

<CodeSelector codes={['']} x='babel/preset-env' />

```shell
npm i -D @babel/core @babel/preset-env
```

babel.config.js를 아래와 같이 작성한다.

<CodeSelector codes={['babel.config.json']} x='babel.config' />

```js
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "useBuiltIns": "usage",
        "corejs": "3.6.5"
      }
    ]
  ]
}
```

추가적으로 사용하고 싶은 프리셋이 있으면 추가하면 된다.

## rollup.config.js

rollup을 설치한다.

<CodeSelector codes={['shell']} x='install rollup' />

```shell
npm install rollup --save-dev
```

rollup.config.js 파일을 생성한다.

아주 기본적인 설정 방법은 아래와 같다.

<CodeSelector codes={['rollup.config.js']} x='rollup.config.js' />

```js
import pkg from './package.json' assert { type: 'json' }

const external = Object.keys(pkg.dependencies)

export default {
  input: 'src/main.js',
  output: {
    file: 'bundle.js',
    format: 'cjs',
  },
  external,
  plugins: [
    /* ... */
  ],
}
```

- input에는 번들링할 코드의 진입점을 지정한다.
- output.file에는 번들링 된 파일의 이름을 지정한다.
- output.format에는 번들링된 파일이 사용할 모듈 시스템을 지정한다.
- external에는 현재 사용하고 있는 외부 모듈(dependencies)을 명시해준다. 여기에 쓰여진 외부 모듈은 번들링된 코드에 직접 포함되지 않고 import 된다.
- plugins에는 사용할 플러그인을 지정한다.

ESM과 CJS 코드 모두 빌드하는 것이 목표이므로 위 코드를 기반으로 작성해본다.

```js
import path from 'path';
import resolve from '@rollup/plugin-node-resolve';
import typescript from '@rollup/plugin-typescript';
import commonjs from '@rollup/plugin-commonjs';
import terser from '@rollup/plugin-terser';
import { babel } from '@rollup/plugin-babel';
import pkg from './package.json' assert { type: 'json' };

const external = Object.keys(pkg.dependencies);

const extensions = ['.js', '.ts', '.tsx'];

function buildJS(input) {
  const parsed = path.parse(input);

  return {
    input: `src/${input}`,
    output: [
      {
        file: `dist/cjs/${parsed.dir}/${parsed.name}.cjs`,
        format: 'cjs',
      },
      {
        file: `dist/esm/${parsed.dir}/${parsed.name}.js`,
        format: 'esm',
      }
    ]
    external,
    plugins: [
      commonjs(),
      resolve({ extensions }),
      typescript(
        declaration: false,
      ),
      babel({ babelHelpers: 'bundled', extensions }),
      terser()
    ],
  };
}

export default [buildJS('index.ts')];
```

아래부터는 이 프로젝트에서 사용할 플러그인들을 설명할 것이다.

### @rollup/plugin-typescript

Rollup과 Typescript 간의 원활한 통합을 위한 Rollup 플러그인이다.

tsconfig.json에 적혀있는 옵션들을 사용해서 번들링을 하게 된다.

```shell
npm i -D @rollup/plugin-typescript tslib
```

- https://github.com/rollup/plugins/tree/master/packages/typescript

### @rollup/plugin-babel

rollup과 babel을 같이 진행하도록 해주는 플러그인이다.

```shell
npm install @rollup/plugin-babel --save-dev
```

- https://github.com/rollup/plugins/tree/master/packages/babel

### @rollup/plugin-node-resolve

node_modules에서 외부 모듈을 사용하기 위해 Node resolution algorithm을 사용하여 모듈을 찾는 롤업 플러그인

tsconfig.json의 nodeResolution에 해당하는 부분이다.

```shell
npm install @rollup/plugin-node-resolve --save-dev
```

- https://github.com/rollup/plugins/tree/master/packages/node-resolve

### @rollup/plugin-commonjs

CJS 모듈을 ES6으로 변환하여 rollup 번들에 포함할 수 있는 롤업 플러그인

외부 모듈이 CJS인 경우 이 플러그인을 사용해야 번들에 포함시킬 수 있다.

```shell
npm install @rollup/plugin-commonjs --save-dev
```

- https://github.com/rollup/plugins/tree/master/packages/commonjs

### @rollup/plugin-terser

terser를 사용해 minification을 해주는 플러그인

```shell
npm i rollup-plugin-terser --save-dev
```

- https://github.com/TrySound/rollup-plugin-terser

## 추가 - declaration 파일에 대하여

번들링을 하면서 가장 헷갈렸던 부분은 CJS와 ESM에 따라서 선언 파일도 달라지는가? 였다.

타입스크립트 4.7 부터 tsc가 `.mts` 파일은 `.d.mts`를 출력하고, `.cts` 파일은 `.d.cts`를 출력한다.

그러면 `.d.mts`와 `.d.cts`은 서로 다른 것인가?

결론부터 얘기하면 그렇지 않다가 맞는 것 같다.

tsc로 간단하게 CJS와 ESM 모듈 시스템을 사용한 코드를 사용해서 선언 파일을 출력 해봤는데 차이가 없었다.

그런데 내가 가장 혼란스러웠던 것은 [토스 tech의 글](https://toss.tech/article/commonjs-esm-exports-field)과 [@toss/slash](https://github.com/toss/slash/blob/main/packages/common/utils/package.json)의 차이였다.

같은 토스에서 쓴 글과 코드인데 블로그에서는 `package.json`에서 exports 필드에 require과 import 각각 선언 파일을 명시하지 않으면 에러가 발생하는 것으로 적혀있고,

@toss/slash의 package.json에서는 그냥 하나의 선언 파일만을 사용하고 있었다.

글과 코드 둘 중 어느 것이 맞는지 확인해보기 위해 직접 CJS와 ESM 환경에서 라이브러리를 설치해보고 실행한 결과 하나의 선언 파일만을 사용했을 때, 코드는 CJS와 ESM 모두 잘 작동하였다.

즉, 그냥 tsc가 생성한 `.d.ts` 파일만 사용해도 된다가 내 결론이다.

(추가적으로 tsc가 생성한 여러 .d.ts 파일들을 하나로 번들링해볼 수 있지만, 여기서는 생략한다.)

그러면 `.d.mts`와 `.d.cts` 각각이 필요한 경우는 언제인가?

이것도 내 생각이지만, 직접 `.mts`와 `.cts` 파일을 작성했을 때 필요한 것이 아닐까?

보통은 귀찮음 때문에 하나의 `.ts` 파일만 작성해서 여러 모듈 시스템을 적용한 코드를 빌드하지만, 직접 각각의 파일을 작성하는 경우도 있을 것 같다.

## References

- [라이브러리 번들링 개선 과정: 커맨드 한 줄로 번들링 끝내기](https://blog.hoseung.me/2023-07-22-improve-library-bundling)
- [Rollup.js - 플러그인으로 완성도를 높이다](https://www.peterkimzz.com/rollupjs-using-plugin)
- [rollup/awesome](https://github.com/rollup/awesome)
- [CommonJS와 ESM에 모두 대응하는 라이브러리 개발하기: exports field](https://toss.tech/article/commonjs-esm-exports-field)
