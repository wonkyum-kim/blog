import { CodeSelector } from '@/components/code-selector.tsx'

# 📝 작성 중...

## react 패키지

`react` 패키지는 React 컴포넌트를 정의하는데 필요한 기능만 포함되어 있다.

보통 웹을 위한 `react-dom` 또는 네이티브 환경을 위한 `react-native`와 같은 React 렌더러와 함께 사용된다.

기본적으로 React는 개발 모드에 존재한다.

개발 버전은 일반적인 실수에 대한 추가적인 경고가 포함되어 있지만, 프로덕션 버전에서는 추가적인 성능 최적화가 포함되어 있고 모든 에러 메시지가 제거된다.

따라서 애플리케이션을 배포할 때, 프로덕션 빌드를 사용하는 것을 잊지 않아야 한다.

참고로 react 패키지에서 개발 버전에 대한 코드는 `__DEV__`로 관리되고 있다.

`react` 패키지에서 export 하고 있는 모듈은 [`index.js`](https://github.com/facebook/react/blob/main/packages/react/index.js)에서 확인 가능하다.

크게 6가지 부분으로 구성되어 있다.

- Internal: React 내부에서 사용되는 객체
- Legacy API: 현재는 사용이 권장되지 않는 API
- Component: 미리 정의된 React 컴포넌트
- API: 컴포넌트를 정의하는데 도움이 되는 API
- Hook: React 훅

아래 설명은 client 기준으로 진행한다. server는 나중에 살펴보기로 한다.

## [Internal]

### \_\_CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE

구현체: [src/ReactSharedInternalsClient.js](https://github.com/facebook/react/blob/main/packages/react/src/ReactSharedInternalsClient.js)

react 패키지 내부에서 사용하는 객체.

개발자에게 export 될 때에는 사용하지 말라는 의미에서 이름이 길게 지어졌고, 내부 코드에서는 `ReactSharedInternals`라는 이름으로 사용된다.

ReactSharedInternals는 react 패키지에서 비어있는 상태로 존재한다.

이 객체는 `shared` 패키지의 ReactSharedInternals.js에서 import되고 다시 export된다.

shared 패키지에서 exoprt 된 ReactSharedInternals의 프로퍼티들은 외부 패키지에서 주입된다.

- ReactSharedInternals.H: React 훅들이 들어있다. `react-reconciler` 패키지에서 주입된다.
- ReactSharedInternals.A: TODO
- ReactSharedInternals.T: TODO
- ReactSharedInternals.S: TODO
- TODO...

## [Legacy API]

### Children

구현체: [src/ReactChildren.js](https://github.com/facebook/react/blob/main/packages/react/src/ReactChildren.js)

문서: https://19.react.dev/reference/react/Children

`Children`은 객체고 그 안에 `props.children`으로 전달된 children에 대해 여러 가지 작업을 할 수 있는 메서드로 구성되어 있다.

React에서 children prop은 항상 배열이 아니다. 그래서 children을 다룰려면 `Children` 메서드가 필요한 것이다.

(children이 항상 배열이 아닌 이유는, 자식이 오직 하나일 때 배열로 만들게 되면 불필요한 메모리 오버헤드가 발생하기 때문이다.)

React에서 자식 노드로 간주되는 것은 Empty nodes(null, undefined, and Booleans), strings, numbers, and React elements다.

React elements를 만나면 그보다 더 깊이 순회하지는 않기 때문에 그 자식 노드들은 개수에 포함되지 않는다.

### Component

구현체: [src/ReactBaseClasses.js](https://github.com/facebook/react/blob/main/packages/react/src/ReactBaseClasses.js)

문서: https://19.react.dev/reference/react/Component

`Component`는 클래스형 컴포넌트를 만들기 위해 사용된다.

구현체를 보면, 함수로 정의되어있으며, 프로토타입에 여러 메서드가 포함된다.

클래스형 컴포넌트를 선언하는 방법은 `Component`를 extend하고 `render` 메서드를 정의해주면 된다.

이제는 사용할 일이 거의 없기 때문에 자세히 보지 않고 넘어간다.

### PureComponent

구현체: [src/ReactBaseClasses.js](https://github.com/facebook/react/blob/main/packages/react/src/ReactBaseClasses.js)

문서: https://19.react.dev/reference/react/PureComponent

`Component`와 비슷하지만 같은 props와 state에 대해 재렌더링을 방지해준다고 하는데, 클래스형 컴포넌트는 넘어가도록 한다.

### cloneElement

구현체: [src/jsx/ReactJSXElement.js](https://github.com/facebook/react/blob/main/packages/react/src/jsx/ReactJSXElement.js)

문서: https://19.react.dev/reference/react/cloneElement

전달된 엘리먼트를 복사하여 반환하는 함수다.

React 19버전에서는 [ref 객체를 prop으로 전달하도록 되어 있다.](https://19.react.dev/blog/2024/04/25/react-19#ref-as-a-prop) 그래서 구현체를 보면 props에 ref를 포함한 모든 prop이 복사되어있다.

`ReactElement` 함수를 사용하여 복사된 React 엘리먼트를 반환한다. (createElement에서 살펴보도록 한다.)

### createElement

구현체: [src/jsx/ReactJSXElement.js](https://github.com/facebook/react/blob/main/packages/react/src/jsx/ReactJSXElement.js)

문서: https://19.react.dev/reference/react/createElement

JSX를 사용하지 않고 직접 React 엘리먼트를 만드는 함수다.

`ReactElement` 함수를 사용하여 새로운 `React 엘리먼트`를 반환한다.

그렇다면 React 엘리먼트란 무엇인가?

아래와 같이 typeof, type, key, ref, props 프로퍼티를 가지고 있는 객체를 의미한다.

<CodeSelector names={['src/jsx/ReactJSXElement.js']} desc='ex3' />

```js
element = {
  $$typeof: REACT_ELEMENT_TYPE,
  type,
  key,
  ref,
  props,
}
```

이 객체가 나중에 DOM으로 변환되는 것이다.

### createRef

구현체: [src/ReactCreateRef.js](https://github.com/facebook/react/blob/main/packages/react/src/ReactCreateRef.js)

문서: https://19.react.dev/reference/react/createRef

`useRef`가 나오기 전까지 ref 객체를 만들기 위해 사용하던 함수다.

### forwardRef

구현체: [src/ReactForwardRef.js](https://github.com/facebook/react/blob/main/packages/react/src/ReactForwardRef.js)

문서: https://19.react.dev/reference/react/forwardRef

`forwardRef`는 ref를 컴포넌트에 전달하기 위해 사용되었던 함수다.

하지만 19버전 부터는 props에 ref를 전달할 수 있으므로 살펴보지 않고 넘어가도록 한다.

### isValidElement

구현체: [src/jsx/ReactJSXElement.js](https://github.com/facebook/react/blob/main/packages/react/src/jsx/ReactJSXElement.js)

문서: https://19.react.dev/reference/react/isValidElement

React 엘리먼트인지 확인해주는 함수다. 그래서 구현은 매우 간단하다.

React 노드는 함수형 컴포넌트가 반환할 수 있는 모든 것을 의미한다.

반면에 React 엘리먼트는 JSX 태그 또는 createElement가 반환한 객체만을 의미한다.

## [Component]

구현체: [shared/ReactSymbols.js](https://github.com/facebook/react/blob/main/packages/shared/ReactSymbols.js)

react 패키지는 단순히 export 하는 역할이고, 실제 정의는 `shared` 패키지에 전역 심볼로 되어 있다.

심볼을 JSX에 전달하면 어떻게 되는 것일까? Babel로 변환된 결과물을 확인해보았다.

<CodeSelector names={['src/index.jsx', 'dist/index.js']} desc='ex1' />

```jsx
const Fragment = Symbol.for('react.fragment')
const app = () => <Fragment></Fragment>
```

```js
const Fragment = Symbol.for('react.fragment')
const app = () => /*#__PURE__*/ React.createElement(Fragment, null)
```

`React.createElement`의 첫 번째 매개변수에 심볼을 그대로 넣어서 변환되는 것을 확인할 수 있다. 즉, 심볼도 React 엘리먼트의 타입이 될 수 있음을 의미한다.

Fragment, Profiler, StrictMode, Suspense가 실제로 어떻게 구현되어 있는지는 다른 패키지를 살펴봐야 할 것이다.

## [API]

### createContext

구현체: [src/ReactContext.js](https://github.com/facebook/react/blob/main/packages/react/src/ReactContext.js)

문서: https://19.react.dev/reference/react/createContext

컴포넌트 외부에서 `context` 객체를 생성할 수 있게 해주는 함수다.

context 객체 그 자체는 아무런 정보도 가지고 있지 않으며, 단지 다른 컴포넌트들이 어떤 컨텍스트를 읽거나 제공받는지를 나타낸다.

context 객체는 2가지 프로퍼티를 가진다. 하지만 19 버전부터 모두 deprecated 되었다.

- `SomeContext.Provider`: 컴포넌트에 컨텍스트 값을 제공한다. (React 19부터는 그냥 SomeContext만 사용해도 동일하다.)
- `SomeContext.Consumer`: 컨텍스트 값을 읽게 해준다. (`useContext`를 사용하는 것이 권장된다.)

<CodeSelector names={['context']} desc='ex2' />

```jsx
// context object를 생성한다.
// optional: 'light'라는 기본 값을 제공해준다.
const ThemeContext = createContext('light')

function App() {
  const [theme, setTheme] = useState('dark')

  // 기본 값 대신 'dark'라는 값을 context value로 설정한다.
  // React 19부터는 ThemeContext.Provider 대신 ThemeContext로 사용해도 된다.
  return (
    <ThemeContext value={theme}>
      <Page />
    </ThemeContext>
  )
}

function Page() {
  // ThemeContext.Consumer는 이제 사용하지 않는다.
  // 대신에 context value를 얻기 위해서 useContext를 사용한다.
  // 또는 use 훅을 사용해도 된다.
  const theme = useContext(ThemeContext)
  return <div>{theme}</div>
}
```

그리고 문서에는 나오지 않는 4가지 프로퍼티도 존재한다.

- `$$typeof`: context 객체의 타입
- `_currentValue`와 `_currentValue2`: React는 여러 concurrent 렌더러를 지원하는 해결 방법으로 렌더러를 primary와 secondary로 구분한다. secondary 렌더러는 분리된 필드에 컨텍스트 값을 저장하기 때문에 이와 같이 두 개의 필드가 필요한 것이다.
- `_threadCount`: 단일 렌더러 내에서 이 컨텍스트가 현재 지원하는 concurrent 렌더러 수를 추적하는데 사용된다.

### use

문서: https://19.react.dev/reference/react/use

훅은 살펴보지 않기로 했지만 `use`는 API로 구분되어 있으므로 무엇인지만 살펴본다.

use는 Promise와 context 값을 읽는 새로운 API다.

하지만 다른 React 훅과는 달리 조건문이나 반복문 안에서도 사용이 가능하다.

Promise와 함께 호출되었을 때, use는 Suspense, error boundary와 결합시킬 수 있다.

Promise의 값을 얻으려면, 서버 컴포넌트의 async 함수 내에서 await를 사용해야 했는데 이제는 클라이언트 컴포넌트 내에서도 가능해졌다.

use를 Promise와 함께 사용하는 가장 좋은 방법은 서버 컴포넌트에서 Promise를 생성해서 클라이언트 컴포넌트에 prop으로 넘기는 것이다.

두 방법의 차이는 아래와 같다.

- 서버 컴포넌트에서 async와 await를 사용하면 Promise 값이 resolve 되기까지 렌더링이 차단된다.
- 클라이언트 컴포넌트에서 use를 사용하면 재렌더링이 발생한다.

### lazy

구현체: [src/ReactLazy.js](https://github.com/facebook/react/blob/main/packages/react/src/ReactLazy.js)

문서: https://19.react.dev/reference/react/lazy

`lazy`는 로딩 중인 컴포넌트의 렌더링이 완료될 때까지 특정 코드의 실행을 지연시켜주는 API다.

lazy에 건네주는 함수는 지연시킬 코드이며 `load`(내부 코드에서는 `ctor`라고 부른다.)라고 부르고 `Promise` 또는 `thenable`을 반환한다.

컴포넌트의 렌더링이 완료되어 load를 호출하면, 반환된 Promise가 resolve 될 때까지 기다리고 resolved 값의 `default`를 React 컴포넌트로 렌더링한다. (즉 resolved될 값(컴포넌트)은 default export 해야 한다는 의미, lazyInitializer의 구현을 살펴보면 알 수 있다.)

반환된 Promise와 Promise의 resolved 값은 저장되기 때문에, React는 load를 다시 호출하지 않는다.

쉽게 정리해보면, 어떤 컴포넌트가 렌더링을 하는데 lazy 부분의 코드는 빼고 렌더링을 하게 된다.

그 컴포넌트의 렌더링이 완료되면, lazy의 load 함수를 호출한다.

load 함수는 Promise(또는 thenable)를 반환하고 값이 resolved 되면 그 값(React 컴포넌트)을 렌더링한다.

resolved 되기 이전까지는 `Suspense`에 전달한 값을 보여주게 된다.

내부 구현을 살펴보면 `lazyInitializer`에서 작업이 이루어진다.

값이 resolve 되면 payload에 그 값을 전달하고, error가 발생하면 에러를 전달한다.

### memo

구현체: [src/ReactMemo.js](https://github.com/facebook/react/blob/main/packages/react/src/ReactMemo.js)

문서: https://19.react.dev/reference/react/memo

`memo`는 컴포넌트의 props가 변하지 않으면 재렌더링을 스킵하게 해주는 함수다.

하지만 항상 스킵이 보장되는 것은 아니다. 성능 최적화를 위해서 React는 여전히 재렌더링할 수 있다.

props의 비교는 `Object.is`로 진행되지만, 직접 비교를 하는 함수를 전달할 수도 있다.

memo로 최적화하는 과정은 정확히 같은 props로 자주 재렌더링 되거나 재렌더링 로직이 비쌀 때만 가치가 있다.

컴포넌트에 건네주는 props가 항상 다르다면, 예를 들어 객체나 함수를 건네준다면 memo는 의미가 없다.

따라서 useMemo와 useCallback을 memo와 같이 사용해야한다.

### cache

구현체: [src/ReactCacheImpl.js](https://github.com/facebook/react/blob/main/packages/react/src/ReactCacheImpl.js)

문서: https://19.react.dev/reference/react/cache

서버 컴포넌트에서 data fetch나 계산 결과를 저장하게 해주는 함수를 반환한다.

클라이언트 컴포넌트에서 실행하면 캐싱 기능은 작동하지 않는다.

`src/ReactCacheClient.js`를 보면 클라이언트 컴포넌트에서 cache는 아직 구현되지 않았다고 적혀있다.

컴포넌트 외부에서 함수를 cache로 감싸고, 반환된 함수를 서버 컴포넌트 내부에서 사용하면 된다.

다시 말하면, 감싸는 것은 컴포넌트 외부에서 반환된 함수를 사용하는 것은 컴포넌트 내부에서다.

`memo`는 클라이언트 컴포넌트에서 props를 비교해 컴포넌트를 렌더링을 스킵하는 것이라면, cache는 서버 컴포넌트에서 data fetch나 계산 결과를 저장해두고 쓰는 것이라고 할 수 있다.

아직까지 ReactQuery나 Next.js fetch에 비해 기능이 많이 부족하기 때문에 대체하기는 힘들어보인다.

### startTransition

구현체: [src/ReactStartTransition.js](https://github.com/facebook/react/blob/main/packages/react/src/ReactStartTransition.js)

문서: https://19.react.dev/reference/react/startTransition

UI 업데이트를 논블로킹으로 할 수 있게 해주는 API다.

블로킹과 논블로킹의 차이는 제어권에 있다.

상태 업데이트를 논블로킹으로 하게 되면, 컴포넌트가 제어권을 가지기 때문에 상태 업데이트의 완료 여부와 상관 없이 다른 작업(e.g. 다른 상태를 업데이트)을 계속 할 수 있게 된다.

구현을 살펴보면 콜백함수를 논블로킹으로 호출하고 다시 원래 컨텍스트로 돌아감을 확인할 수 있다.

## [Hooks]

`react-reconciler` 패키지에서 구현되고 ReactSharedInternals에 주입되기 때문에 react 패키지에서는 단순히 사용만 하고 있다. (react/src/ReactHooks.js 참고)

이 글에서는 훅이 주입되는 과정은 살펴보지 않고 구현과 역할에 대해서 살펴본다. (주입 과정은 react-reconciler에서 다루도록 한다.)

### useId

TODO...
