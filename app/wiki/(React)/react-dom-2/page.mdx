import { CodeSelector } from '@/components/code-selector.tsx'

# 📝 작성 중...

## react-dom/client

### createRoot

`createRoot`는 `ReactDOMRoot`를 생성하는 함수다.

<CodeSelector names={['index.js']} desc='ex1' />

```jsx
import { createRoot } from 'react-dom/client'

// root: ReactDOMRoot
const root = createRoot(document.getElementById('root'))
```

> 지금부터 createRoot가 동작하는 과정을 살펴볼 것인데, react-reconciler 부분을 먼저 읽고 오는 것이 도움이 된다.

1단계: createContainer를 호출하여 FiberRootNode를 생성한다.

createContainer는 createFiberRoot를 호출하고, createFiberRoot는 FiberRootNode를 생성하여 반환한다.

FiberRootNode는 Fiber 객체를 포함하고 있는 객체라고 생각하면된다.

disableLegacyMode가 true이기 때문에 Fiber.mode는 ConcurrentMode로 설정된다.

실제 Fiber 객체가 생성되는 createFiber 부분은 react-reconciler를 참고한다.

(TODO)캐시 관련해서는 아직 무엇인지 파악하지 못했다.

마지막으로 Fiber 객체에 update 큐를 추가해주고 마무리된다.

<CodeSelector
  names={['createRoot', 'createContainer', 'createFiberRoot', 'createHostRootFiber']}
  desc='ex2'
/>

```ts {6-11} showLineNumbers
export function createRoot(
  container: Element | Document | DocumentFragment,
  options?: CreateRootOptions
): RootType {
  /* ... */
  // 1단계: createContainer를 호출하여 FiberRootNode를 생성한다.
  const root = createContainer(
    container,
    ConcurrentRoot
    /* ... */
  )
  /* ... */
}
```

```ts {7-11} showLineNumbers
export function createContainer(
  containerInfo: Container,
  tag: RootTag
  /* ... */
): OpaqueRoot {
  // ...
  return createFiberRoot(
    containerInfo,
    tag
    /* ... */
  )
}
```

```ts {7-12, 16-19, 43-44} showLineNumbers
export function createFiberRoot(
  containerInfo: Container,
  tag: RootTag,
  /* ... */
): FiberRoot {

  // 1. FiberRootNode를 생성한다.
  const root: FiberRoot = (new FiberRootNode(
    containerInfo,
    tag,
    /* ... */
  ): any);

  /* ... */

  // 2. FiberRootNode.current에 Fiber 객체를 넣는다.
  const uninitializedFiber = createHostRootFiber(tag, isStrictMode);
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;

  // 3. cache 관련
  if (enableCache) {
    const initialCache = createCache();
    retainCache(initialCache);

    // The pooledCache is a fresh cache instance that is used temporarily
    // for newly mounted boundaries during a render. In general, the
    // pooledCache is always cleared from the root at the end of a render:
    // it is either released when render commits, or moved to an Offscreen
    // component if rendering suspends. Because the lifetime of the pooled
    // cache is distinct from the main memoizedState.cache, it must be
    // retained separately.
    root.pooledCache = initialCache;
    retainCache(initialCache);
    const initialState: RootState = {
      element: initialChildren,
      isDehydrated: hydrate,
      cache: initialCache,
    };
    uninitializedFiber.memoizedState = initialState;
  } else { /* ... */ }

  // 4. Fiber 객체에 updateQueue를 추가한다.
  initializeUpdateQueue(uninitializedFiber);

  return root;
}
```

```ts {4, 10} showLineNumbers
export function createHostRootFiber(tag: RootTag, isStrictMode: boolean): Fiber {
  let mode
  if (disableLegacyMode || tag === ConcurrentRoot) {
    mode = ConcurrentMode
    /* ... */
  } else {
    mode = NoMode
  }
  /* ... */
  return createFiber(HostRoot, null, null, mode)
}
```

2단계: container에 Fiber 객체 설정하기

container는 createRoot 호출 시 전달한 `document.getElementById('root')`다.

여기에 Fiber 객체를 설정하는 과정을 거친다.

<CodeSelector names={['createRoot', 'markContainerAsRoot']} desc='ex3' />

```ts showLineNumbers {7-8}
export function createRoot(
  container: Element | Document | DocumentFragment,
  options?: CreateRootOptions
): RootType {
  /* ... */
  // 1단계: createContainer를 호출하여 FiberRootNode를 생성한다.
  // 2단계: container에 Fiber 객체 설정하기
  markContainerAsRoot(root.current, container)
}
```

```ts showLineNumbers {3}
export function markContainerAsRoot(hostRoot: Fiber, node: Container): void {
  // $FlowFixMe[prop-missing]
  node[internalContainerInstanceKey] = hostRoot
}
```

3단계: 이벤트 설정

listenToAllSupportedEvents를 보면, container에 listeningMarker라는 필드를 설정한다.

그리고 selectionchange를 제외한 모든 네이티브 이벤트에 대해서 listenToNativeEvent를 호출한다.

selectionchange를 제외하는 이유는 [버블링이 일어나지 않는 이벤트](https://developer.mozilla.org/en-US/docs/Web/API/Document/selectionchange_event)이기 때문이다.

(그래서 html DOM에만 직접 이벤트를 설정한다. 21 - 26 라인)

그리고 네이티브 이벤트 중 container에 위임하면 안되는 것들에 대해서 따로 처리하는 모습을 볼 수 있는데, 그 이유는 특정 이벤트가 DOM에서 일관되게 버블링되지 않기 때문이다.

listenToNativeEvent는 addTrappedEventListener를 호출한다.

이후 과정은 너무 복잡하고 브라우저의 스펙에 따라서 작성된 코드라서 분석하기가 어려웠다.

그래도 간단히 살펴보면, 브라우저 이벤트들이 우선순위(FiberLane)에 따라서 실행되도록 하고, container에 특정 이벤트가 실행되었을 때 실행될 이벤트 리스너들을 addEventListenr로 추가하는 것을 볼 수 있었다.

예를 들어, 컴포넌트에 onClick을 할당했을 때, 개발자가 할당한 핸들러 말고도 리액트에서 미리 할당된 숨겨진 핸들러가 먼저 작동되고 있었다는 것이다.

<CodeSelector
  names={['createRoot', 'listenToAllSupportedEvents', 'listenToNativeEvent']}
  desc='ex4'
/>

```ts showLineNumbers {8-13}
export function createRoot(
  container: Element | Document | DocumentFragment,
  options?: CreateRootOptions
): RootType {
  /* ... */
  // 1단계: createContainer를 호출하여 FiberRootNode를 생성한다.
  // 2단계: container에 Fiber 객체 설정하기
  // 3단계: 이벤트 설정
  const rootContainerElement: Document | Element | DocumentFragment =
    container.nodeType === COMMENT_NODE
      ? (container.parentNode: any)
      : container;
  listenToAllSupportedEvents(rootContainerElement);
}
```

```ts showLineNumbers {5, 9-14, 21-26}
const listeningMarker = '_reactListening' + Math.random().toString(36).slice(2);

export function listenToAllSupportedEvents(rootContainerElement: EventTarget) {
  if (!(rootContainerElement: any)[listeningMarker]) {
    (rootContainerElement: any)[listeningMarker] = true;
    allNativeEvents.forEach(domEventName => {
      // We handle selectionchange separately because it
      // doesn't bubble and needs to be on the document.
      if (domEventName !== 'selectionchange') {
        if (!nonDelegatedEvents.has(domEventName)) {
          listenToNativeEvent(domEventName, false, rootContainerElement);
        }
        listenToNativeEvent(domEventName, true, rootContainerElement);
      }
    });
    const ownerDocument =
      (rootContainerElement: any).nodeType === DOCUMENT_NODE
        ? rootContainerElement
        : (rootContainerElement: any).ownerDocument;
    if (ownerDocument !== null) {
      // The selectionchange event also needs deduplication
      // but it is attached to the document.
      if (!(ownerDocument: any)[listeningMarker]) {
        (ownerDocument: any)[listeningMarker] = true;
        listenToNativeEvent('selectionchange', false, ownerDocument);
      }
    }
  }
}
```

```ts showLineNumbers {10}
export function listenToNativeEvent(
  domEventName: DOMEventName,
  isCapturePhaseListener: boolean,
  target: EventTarget
): void {
  let eventSystemFlags = 0
  if (isCapturePhaseListener) {
    eventSystemFlags |= IS_CAPTURE_PHASE
  }
  addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener)
}
```

4단계: ReactDOMRoot 반환

FiberRootNode를 포함하고 있는 ReactDOMRoot 객체를 생성하여 반환한다.

즉 다음과 같은 포함관계가 형성된 것이다.

ReactDOMRoot \< FiberRootNode \< Fiber

ReactDOMRoot에는 render와 unmount 메서드가 추가되는데, 이것은 밑에서 살펴보기로 한다.

<CodeSelector names={['createRoot', 'ReactDOMRoot']} desc='ex5' />

```ts showLineNumbers {9-10}
export function createRoot(
  container: Element | Document | DocumentFragment,
  options?: CreateRootOptions
): RootType {
  /* ... */
  // 1단계: createContainer를 호출하여 FiberRootNode를 생성한다.
  // 2단계: container에 Fiber 객체 설정하기
  // 3단계: 이벤트 설정
  // 4단계: ReactDOMRoot 반환
  return new ReactDOMRoot(root)
}
```

```ts showLineNumbers {2}
function ReactDOMRoot(internalRoot: FiberRoot) {
  this._internalRoot = internalRoot
}
```

### ReactDOMRoot.render

createRoot가 반환한 객체의 render 메서드에 대해서 살펴본다.

TODO

### ReactDOMRoot.unmount

TODO

### hydrateRoot

TODO
