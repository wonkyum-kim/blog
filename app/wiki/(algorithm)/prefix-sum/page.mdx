import { CodeSelector } from '@/components/code-selector.tsx'

## 정적인 누적 합

배열의 $i$번째 원소부터 $j$번째 원소까지의 합을 구하기 위해서는 단순히 for 문 한 번을 사용해 구할 수 있습니다.

하지만 배열의 원소가 변하지 않고, 이런 쿼리가 여러 번 계속될 경우 `누적 합`을 사용해 $O(1)$ 시간에 빠르게 구할 수 있습니다.

누적 합의 아이디어는 이전까지의 모든 원소의 합을 저장해두는 것입니다.

### 1차원 누적 합

1차원 누적 합은 원래 배열 `v`과 이전까지의 모든 원소의 합을 저장하는 배열 `sum`을 관리하면 됩니다.

a부터 b까지의 모든 원소의 합은 1부터 b까지의 모든 원소의 합에서 1부터 a - 1까지의 모든 원소의 합을 빼면 됩니다.

(계산의 편의를 위해 index가 1부터 시작합니다.)

<CodeSelector names={['js']} desc='js1' />

```js
const sum = new Array(n + 1).fill(0)

for (let i = 1; i <= n; ++i) {
  sum[i] = sum[i - 1] + v[i]
}

// a번째 원소부터 b번째 원소까지의 합
console.log(sum[b] - sum[a - 1])
```

### 2차원 누적 합

2차원 누적 합은 1차원 누적 합과 크게 다르지 않습니다.

전체에서 겹치는 부분을 빼주고 현재 원소를 더해주면 됩니다.

<CodeSelector names={['js']} desc='js2' />

```js
const sum = array2d(n + 1, m + 1, 0)

for (let i = 1; i <= n; ++i) {
  for (let j = 1; j <= m; ++j) {
    sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + v[i][j]
  }
}

// (a1, b1)에서 (a2, b2)까지의 합
console.log(sum[a2][b2] - sum[a2][b1 - 1] - sum[a1 - 1][b2] + sum[a1 - 1][b1 - 1])
```

## 동적인 누적 합 (imos)

주어진 구간에 속한 모든 원소 또는 특정 원소 하나를 업데이트하고 누적 합을 구하기 위해서는 여러 가지 방법이 존재하지만, 간단한 `imos` 방법에 대해서 소개합니다.

### 1차원 누적 합

구간 (a) 부터 (b) 까지 k를 더한다고 했을 때, `sum[a]`에 k를 더하고, `sum[b + 1]`에 -k를 더합니다.

그리고 누적 합을 구해주면 됩니다.

<CodeSelector names={['imos']} desc='js3' />

```text
// 초기 상태
[0,0,0,0,0,0]

// [0, 4]에 1만큼 더하고 싶다면 [0]에 1, [5]에 -1을 더함
[1,0,0,0,0,-1]

// 누적 합을 구함
[1,1,1,1,1,0]
```

### 2차원 누적 합

2차원도 다르지 않습니다.

구간 (a, b)에서 (c, d)까지 k만큼 더한다고 했을 때, 다음과 같이 진행합니다.

- `udp[a][b] += k`
- `if (c + 1 <= n) udp[c + 1][b] -= k`
- `if (d + 1 <= m) udp[a][d + 1] -= k`
- `if (c + 1 <= n && d + 1 <= m) udp[c + 1][d + 1] += k`

그리고 누적 합을 행과 열 순서로 각각 진행합니다.

<CodeSelector names={['js']} desc='js4' />

```js
// 아래로
for (let i = 2; i <= n; ++i) {
  for (let j = 1; j <= m; ++j) {
    udp[i][j] += udp[i - 1][j]
  }
}

// 옆으로
for (let i = 1; i <= n; ++i) {
  for (let j = 2; j <= m; ++j) {
    udp[i][j] += udp[i][j - 1]
  }
}

// 원래 배열에 더함
for (let i = 1; i <= n; ++i) {
  for (let j = 1; j <= m; ++j) {
    v[i][j] += udp[i][j]
  }
}

// 누적합을 구함
for (let i = 1; i <= n; ++i) {
  for (let j = 1; j <= m; ++j) {
    sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + v[i][j]
  }
}
```

## References

- [[Tutorial] 1D and 2D constant time per query range updates (a.k.a difference arrays)](https://codeforces.com/blog/entry/86420)
