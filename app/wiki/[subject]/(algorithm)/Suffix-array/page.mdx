import { CodeSelector } from '@/components/code-selector.tsx'

## 접미사 배열

문자열의 접미사 배열은 가능한 접미사들을 사전 순으로 정렬해둔 것이다.

접미사 배열 `sa`에는 접미사가 아니라 원래 문자열에서 접미사가 시작되는 위치를 저장한다.

문자열을 `s`, i위치 문자부터 t개의 문자로 이루어진 부분 문자열을 `s[i..t]`라고 한다.

i + t - 1이 s의 길이 n보다 크거나 같다면 `s[i..]`으로 표시하기로 하자.

그리고 `s[i..t]`가 정렬되었을 때의 등수를 `rank[i] >= 1`라고 한다.

mississipi의 접미사들을 구해보면 아래와 같다.

| i   | s[i..]     | rank[i] |
| --- | ---------- | ------- |
| 0   | mississipi | 5       |
| 1   | ississipi  | 4       |
| 2   | ssissipi   | 10      |
| 3   | sissipi    | 8       |
| 4   | issipi     | 3       |
| 5   | ssipi      | 9       |
| 6   | sipi       | 7       |
| 7   | ipi        | 2       |
| 8   | pi         | 6       |
| 9   | i          | 1       |

이것을 정렬하면 아래와 같이 rank가 증가하는 순서대로 나타난다.

| i   | s[sa[i]..] | rank[sa[i]] | sa[i] |
| --- | ---------- | ----------- | ----- |
| 0   | i          | 1           | 9     |
| 1   | ipi        | 2           | 7     |
| 2   | issipi     | 3           | 4     |
| 3   | ississipi  | 4           | 1     |
| 4   | mississipi | 5           | 0     |
| 5   | pi         | 6           | 8     |
| 6   | sipi       | 7           | 6     |
| 7   | sissipi    | 8           | 3     |
| 8   | ssipi      | 9           | 5     |
| 9   | ssissipi   | 10          | 2     |

접미사 배열 sa를 구하는 방법은 길이가 t인 모든 부분 문자열에 대해서 정렬을 하고, t를 2배씩 늘리는 것을 반복하는 것이다.

먼저 t가 1인 경우부터 생각해보자. `s[i..1]`에는 i, m, s, p가 등장하고, rank는 차례대로 1, 2, 3, 4가 된다. (알파벳 순)

| i   | s[i..1] | rank[i] |
| --- | ------- | ------- |
| 0   | m       | 2       |
| 1   | i       | 1       |
| 2   | s       | 4       |
| 3   | s       | 4       |
| 4   | i       | 1       |
| 5   | s       | 4       |
| 6   | s       | 4       |
| 7   | i       | 1       |
| 8   | p       | 3       |
| 9   | i       | 1       |

rank 순서대로 정렬하면, sa를 구할 수 있다.

| i   | s[sa[i]..1] | rank[sa[i]] | sa[i] |
| --- | ----------- | ----------- | ----- |
| 0   | i           | 1           | 9     |
| 1   | i           | 1           | 7     |
| 2   | i           | 1           | 1     |
| 3   | i           | 1           | 4     |
| 4   | m           | 2           | 0     |
| 5   | p           | 3           | 8     |
| 6   | s           | 4           | 6     |
| 7   | s           | 4           | 3     |
| 8   | s           | 4           | 5     |
| 9   | s           | 4           | 2     |

이제 길이가 t = 2인 부분 문자열들과 등수를 구해보자.

길이가 문자열을 넘어간다면 가능한 길이까지만 설정한다.

그리고 이번에도 rank를 구할 것인데, `s[i..2]`는 길이를 절반씩 쪼개면 길이가 1인 문자열이 나온다.

앞쪽 문자열의 등수는 `rank[i]`이고, 뒤쪽 문자열의 등수는`rank[i + t]`이다.

뒤쪽 문자열의 등수가 없다면 가장 높은 등수라는 의미에서 0을 할당한다.

앞쪽 문자열의 등수와 비교하고, 서로 같다면 뒤쪽 문자열의 등수까지 비교해서 새로운 등수를 만들어낸다.

다시 말하면, (frontRank, backRank) pair를 서로 비교하여 정렬을 하는 것이다.

| i   | s[i..2] | frontRank | backRank | newRank |
| --- | ------- | --------- | -------- | ------- |
| 0   | `m`i    | 2         | 1        | 4       |
| 1   | `i`s    | 1         | 4        | 3       |
| 2   | `s`s    | 4         | 4        | 7       |
| 3   | `s`i    | 4         | 1        | 6       |
| 4   | `i`s    | 1         | 4        | 3       |
| 5   | `s`s    | 4         | 4        | 7       |
| 6   | `s`i    | 4         | 1        | 6       |
| 7   | `i`p    | 1         | 3        | 2       |
| 8   | `p`i    | 3         | 1        | 5       |
| 9   | `i`     | 1         | 0        | 1       |

이제 newRank를 rank로 옮기고 정렬을 하면 아래와 같다.

| i   | s[sa[i]..2] | rank[sa[i]] | sa[i] |
| --- | ----------- | ----------- | ----- |
| 0   | i           | 1           | 9     |
| 1   | ip          | 2           | 7     |
| 2   | is          | 3           | 1     |
| 3   | is          | 4           | 4     |
| 4   | mi          | 5           | 0     |
| 5   | pi          | 6           | 8     |
| 6   | si          | 7           | 6     |
| 7   | si          | 8           | 3     |
| 8   | ss          | 9           | 5     |
| 9   | ss          | 10          | 2     |

이와 같은 과정을 t = 4, 8일 때 해주면 모든 접미사에 대해 접미사배열을 구할 수 있게 된다.

### $O(n{\log^{2}{n}})$ 구현

logn번 동안 nlogn번 정렬하므로 $O(n{\log^{2}{n}})$시간이 걸린다.

정렬 방법을 nlogn이 아니라 n으로 바꾼다면, 시간을 $O(n{\log{n}})$으로 줄일 수 있다.

<CodeSelector names={['index.js']} desc='ex1' />

```js showLineNumbers
function suffixArray(str) {
  const n = str.length
  const sa = new Array(n).fill(0)
  const rank = new Array(n + 1).fill(0)
  const temp = new Array(n + 1).fill(0)

  // 아스키코드를 등수로 변환한다.
  const check = new Array(26).fill(0)
  for (let i = 0; i < n; ++i) check[str[i].charCodeAt() - 'a'.charCodeAt()] = 1
  for (let i = 1; i < 26; ++i) check[i] += check[i - 1]

  for (let i = 0; i < n; ++i) {
    rank[i] = check[str[i].charCodeAt() - 'a'.charCodeAt()]
    sa[i] = i
  }

  for (let t = 1; t < n; t *= 2) {
    // firstRank끼리 비교하고 같으면 backRank를 비교한다.
    const comp = (a, b) => {
      let rank1 = rank[a]
      let rank2 = rank[b]
      if (rank1 === rank2) {
        rank1 = a + t < n ? rank[a + t] : 0
        rank2 = b + t < n ? rank[b + t] : 0
      }
      return rank1 - rank2
    }
    sa.sort(comp)

    temp[sa[0]] = 1
    for (let i = 1; i < n; ++i) {
      temp[sa[i]] = temp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) < 0 ? 1 : 0)
    }

    for (let i = 0; i < n; ++i) rank[i] = temp[i]
  }

  return sa
}
```

### $O(n{\log{n}})$ 구현

counting sort를 하면 더 빠른 시간에 접미사 배열을 구할 수 있다.

이때, (frontRank, backRank)를 비교하여 정렬하기 위해서 stable sort가 필요하다.

stable sort는 같은 값이라면 처음 가진 순서를 유지한 상태를 유지해야 한다.

예를 들어 i가 3과 5에서 backRank가 서로 같다고 해보자.

frontRank가 서로 다르다면, 정렬할 때 3이 5보다 앞에 오는 것은 자명하다.

하지만 frontRank도 서로 같다면, 인덱스 순서에 따라서 3이 5보다 앞에 오도록 해야한다.

누적 합을 통해서 같은 값들이 존재하더라도 몇 번째 등수인지 알 수 있고, i를 뒤에서부터 살펴보면서 할당하므로 안정적인 정렬이 가능하다.

<CodeSelector names={['index.js']} desc='ex2' />

```js showLineNumbers
function suffixArray(str) {
  const n = str.length

  const sa = new Array(n).fill(0)
  const rank = new Array(n + 1).fill(0)
  const temp = new Array(n + 1).fill(0)

  const m = Math.max(27, n + 1)
  const count = new Array(m).fill(0)
  const idx = new Array(m).fill(0)

  const check = new Array(26).fill(0)
  for (let i = 0; i < n; ++i) check[str[i].charCodeAt() - 'a'.charCodeAt()] = 1
  for (let i = 1; i < 26; ++i) check[i] += check[i - 1]

  for (let i = 0; i < n; ++i) {
    rank[i] = check[str[i].charCodeAt() - 'a'.charCodeAt()]
    sa[i] = i
  }

  for (let t = 1; t < n; t *= 2) {
    const comp = (a, b) => {
      let rank1 = rank[a]
      let rank2 = rank[b]
      if (rank1 === rank2) {
        rank1 = a + t < n ? rank[a + t] : 0
        rank2 = b + t < n ? rank[b + t] : 0
      }
      return rank1 - rank2
    }

    for (let i = 0; i < m; ++i) count[i] = 0
    for (let i = 0; i < n; ++i) count[i + t < n ? rank[i + t] : 0]++
    for (let i = 1; i < m; ++i) count[i] += count[i - 1]
    // idx[x] = i:  s[i..t]의 backRank가 x번째이다.
    for (let i = n - 1; i >= 0; --i) idx[--count[i + t < n ? rank[i + t] : 0]] = i

    for (let i = 0; i < m; ++i) count[i] = 0
    for (let i = 0; i < n; ++i) count[rank[i]]++
    for (let i = 1; i < m; ++i) count[i] += count[i - 1]
    for (let i = n - 1; i >= 0; --i) sa[--count[rank[idx[i]]]] = idx[i]

    temp[sa[0]] = 1
    for (let i = 1; i < n; ++i) {
      temp[sa[i]] = temp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) < 0 ? 1 : 0)
    }

    for (let i = 0; i < n; ++i) rank[i] = temp[i]
  }

  return sa
}
```

## LCP

`LCP(Longest Common prefix)` 배열은 각 접미사 배열에서 현재 접미사와 이전 접미사의 최장 공통 접두사를 저장하는 배열이다. (정의에 따라서 현재 접미사와 이후 접미사의 최장 공통 접두사로도 생각할 수 있다.)

접미사 s[i..]의 LCP 값이 x라고 했을 때, 이 접미사의 맨 앞 글자를 제거한 접미사 s[i + 1..]의 LCP 값은 최소한 x - 1이 되어야함을 알 수 있다.

예를 들어 2번째 접미사 `issi`pi와 3번째 접미사 `issi`ssipi를 살펴보면 3번째 접미사의 LCP 값은 4이다.

각 접미사에서 맨 앞 한글자를 지우면 `ssi`pi와 `ssi`ssipi가 되고 이는 각각 8번째와 9번째 접미사이며, 9번째 접미사는 최소한 4 - 1개 문자가 8번째 접미사와 같음을 알 수 있다.

따라서 9번째 접미사의 LCP를 구할 때, 앞의 3개 문자는 살펴보지 않아도 되는 것이다.

sa[i] = x의 의미는 접미사들을 사전 순으로 정렬했을 때, i번째 접미사가 s[x..]라는 의미다.

반대로 isa[x] = i의 의미는 접미사 s[x..]는 접미사들을 사전 순으로 정렬했을 때, i번째 접미사라는 의미가 된다.

<CodeSelector names={['index.js']} desc='ex3' />

```js showLineNumbers
function LCP(str) {
  const n = str.length
  const sa = suffixArray(str)
  const isa = new Array(n).fill(0)
  const lcp = new Array(n).fill(0)

  // 접미사 s[sa[i]..]의 등수는 i
  for (let i = 0; i < n; ++i) isa[sa[i]] = i

  for (let i = 0, l = 0; i < n; ++i, l = Math.max(l - 1, 0)) {
    // 0번째 접미사는 패스한다.
    if (isa[i] === 0) continue
    // isa[i]번째 접미사와 isa[i] - 1번째 접미사를 비교한다.
    // i : isa[i]번째 접미사가 시작하는 인덱스
    // j: isa[i] - 1번째 접미사가 시작하는 인덱스 -> sa[isa[i] - 1]
    // 처음 앞 l개는 비교하지 않아도 된다.
    for (let j = sa[isa[i] - 1]; str[i + l] === str[j + l]; ++l);
    lcp[isa[i]] = l
  }

  return lcp
}
```

## 접미사 배열과 LCP 배열이 의미하는 것

### 접미사 배열과 LCP 배열

문자열 s의 접미사들의 접두사는 s의 부분 문자열이 된다.

부분 문자열의 부분 문자열도 s의 부분 문자열이므로, s의 접미사들의 접두사의 접두사도 s의 부분 문자열이 된다.

따라서 사전 순으로 정렬된 접미사 배열에서 인접한 두 접미사들의 최장 공통 접두사는 s의 부분 문자열이 되고, 최장 공통 접두사의 접두사도 s의 부분 문자열이 된다.

그리고 이 최장 공통 접두사의 접두사들은 s의 모든 부분 문자열 중에서 두 번 이상 등장하는 부분 문자열이다.

### 두 번 이상 등장하는 부분 문자열 중에서 길이가 가장 긴 것

LCP 배열은 인접한 두 접미사의 최장 공통 접두사의 길이를 가지고 있다.

어떤 접미사 s[sa[i]..]의 LCP[i] 값이 3이라면, 두 번 이상 등장하는 부분 문자열 s[sa[i]..1], s[sa[i]..2], s[sa[i]..3]이 존재하고, 그 중에서 가장 길이가 긴 것이 3이라는 의미가 된다.

따라서 LCP 배열의 최댓값은 두 번 이상 등장하는 부분 문자열 중에서 길이가 가장 긴 것이 된다.

### 부분 문자열 중에서 서로 다른 부분 문자열의 개수

문자열 s의 모든 부분 문자열의 개수는 문자열 길이 n에서 2개를 뽑아 시작과 끝을 할당해준 것이다.

즉 $_nC_2$이다.

이 중에서 서로 다른 부분 문자열의 개수를 구하려면, 두 번 이상 등장하는 부분 문자열을 제거해야 한다.

s = ababc라고 해보자.

s의 모든 부분 문자열은 [a, b, a, b, c, ab, ba, bc, ab, aba, bab, abc, abab, babc, ababc]이며 총 15개다.

여기서 두 번 이상 등장하는 부분 문자열은 [a, a, b, b, ab, ab]이다.

sa 배열은 [ababc, abc, babc, bc, c]이며, lcp 배열은 [0, 2, 0, 1, 0]이다.

lcp 배열을 통해서 최장 공통 접두사의 접두사들을 살펴보면, [a, ab, b]가 된다.

즉, 각 최장 공통 접두사들의 접두사들은 두 번 이상 등장하는 것들이므로 전체에서 lcp 배열의 합을 빼주면 서로 다른 부분 문자열의 개수를 구할 수 있다.

### 두 번 이상 등장하는 서로 다른 부분 문자열의 개수

위에서 최장 공통 접두사들의 접두사들을 살펴보았을 때 [a, ab, b]가 나왔다.

하지만 이처럼 항상 하나씩 나오는 것은 아니다.

예를 들어, s = aabaab라고 해보자.

이때 sa는 [aab, aabaab, ab, abaab, b, baab]이며, lcp 배열은 [0, 3, 1, 2, 0, 1]이다.

이를 통해 최장 공통 접두사들의 접두사들을 살펴보면 [a, aa, aab, a, a, ab, b]가 된다.

최장 공통 접두사들의 접두사들은 두 번 이상 등장하는 부분 문자열이고, 이 중에서 서로 다른 두 번 이상 등장하는 부분 문자열을 구하고 싶다면 그냥 set에 넣어서 [a, aa, aab, ab, b]를 구할 수 있다.

하지만 인접한 접미사들의 lcp 관계만 살펴보는 것만으로도 가능하다.

인접한 두 lcp 배열이 증가할 때 차를 더해주면 두 번 이상 등장하는 서로 다른 부분 문자열의 개수를 구할 수 있다.

| s[sa[i]..] | lcp의 접두사들   | lcp[i] | 서로 다른 부분 문자열의 개수 |
| ---------- | ---------------- | ------ | ---------------------------- |
| aab        |                  | 0      |                              |
| aabaab     | `a`, `aa`, `aab` | 3      | (3 - 0)개                    |
| ab         | a                | 1      |                              |
| abaab      | a,`ab`           | 2      | (2 - 1)개                    |
| b          |                  | 0      |                              |
| baab       | `b`              | 1      | (1 - 0)개                    |
