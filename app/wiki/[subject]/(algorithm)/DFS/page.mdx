import { CodeSelector } from '@/components/code-selector.tsx'

## DFS

DFS는 가능한 한 그래프에서 더 깊이 탐색하는 방법이다.

노드를 탐색하고 인접한 노드를 재귀적으로 탐색하게 된다.

문제에 따라서 조금씩 구현은 달라지지만 보통 아래와 같이 진행된다.

<CodeSelector names={['dfs.js']} desc='ex1' />

```js
function dfs(curr) {
  if (visited[curr]) return
  visited[curr] = true
  for (const next of curr) {
    // ...
    dfs(next)
  }
}
```

각 정점과 간선을 한 번씩 살펴보므로 총 수행시간은 $Θ(V + E)$이다.

## DFS 트리

DFS의 결과로 DFS 트리를 만들 수 있다.

DFS 트리의 간선은 4가지로 분류할 수 있다.

- tree edge: DFS 트리의 간선
- forward edge: 무방향 그래프인 경우 조상-자손을 연결하는 간선, 방향 그래프인 경우 조상에서 자손을 연결하는 간선을 의미한다.
- backward edge: 방향 그래프에서 자손에서 조상을 연결하는 간선을 의미하며, 사이클이 존재함을 나타낸다.
- cross edge: 위 3가지 간선을 제외한 간선을 의미한다.

## 사이클

backward edge를 발견하면 사이클이 존재함을 알 수 있다.

DFS 탐색 시 노드에 색을 칠하는 방법을 사용한다.

- white: 아직 방문하지 않은 노드
- gray: DFS가 진행 중인 노드
- black: DFS가 끝난 노드

gray 정점을 다시 만났을 때 backward egde가 존재하며 사이클이 있다고 판단할 수 있다.

<CodeSelector names={['dfs.js']} desc='ex2' />

```js
function dfs(curr) {
  // black
  if (dp[curr] !== white && dp[curr] !== gray) return dp[curr]

  // white
  if (dp[curr] === white) {
    for (const next of curr) {
      const prev = dp[curr]
      dp[curr] = gray
      // e.g. compare
      dp[curr] = Math.max(dfs(next), prev)
    }
    return dp[curr]
  }

  // gray
  if (dp[curr] === gray) {
    // cycle!
    // e.g. return Infinity
    return (dp[curr] = Infinity)
  }
}
```
