import { CodeSelector } from '@/components/code-selector.tsx'
import { ImageContainer } from '@/components/image-container/image-container.tsx'
import Image from 'next/image'
import pic1 from '/public/Algorithm/seg1.jpg'
import pic2 from '/public/Algorithm/lst1.jpg'
import pic3 from '/public/Algorithm/lst2.jpg'
import pic4 from '/public/Algorithm/lst3.jpg'
import pic5 from '/public/Algorithm/lst4.jpg'
import pic6 from '/public/Algorithm/lst5.jpg'
import pic7 from '/public/Algorithm/lst6.jpg'

## 레이지 세그먼트 트리

`레이지 세그먼트 트리`는 값의 변경을 구간 단위로 할 수 있게 해주는 세그먼트 트리다.

보통 재귀 구현을 사용하는데, 반복문으로도 구현이 가능하지만 시간 복잡도가 더 크다.

레이지 세그먼트 트리에서는 `tree`와 `lazy` 2개의 트리를 관리한다.

세그먼트 트리를 업데이트할 때, 구간을 완전히 포함하는 노드를 만난다면 더 아래로 진행하지 않는다.

예를 들어 아래와 같은 세그먼트 트리가 있다고 하자.

<ImageContainer>
  <Image
    src={pic1}
    alt='segment tree'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

구간 [1, 7]의 원소에 1을 더하는 쿼리를 실행해보자.

구간 [1, 7]은 [1, 1], [2, 3], [4, 7] 3개의 구간으로 나눌 수 있고, 해당 구간을 담당하는 노드까지만 업데이트하고, 아래로 더 이상 진행하지 않는다.

대신에 어디까지 진행해두었는지를 lazy에 표시해둔다.

<ImageContainer>
  <Image
    src={pic2}
    alt='lazy segment tree update'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

그리고 구간 [1, 4]의 원소의 합을 구하는 쿼리를 실행해보자.

구간 [1, 4]는 [1, 1], [2, 3], [4, 4] 3개의 구간으로 나눌 수 있다.

먼저 구간 [1, 1] 살펴본다. 해당 경로에 lazy가 없으므로 바로 찾을 수 있다.

<ImageContainer>
  <Image
    src={pic3}
    alt='lazy segment tree sum'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

다음으로 구간 [2, 3]을 살펴본다. 마찬가지로 경로에 lazy가 없다.

<ImageContainer>
  <Image
    src={pic4}
    alt='lazy segment tree sum'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

구간 [4, 4]를 살펴본다. 경로 중간에 lazy를 가지고 있는 노드가 존재한다.

<ImageContainer>
  <Image
    src={pic5}
    alt='lazy segment tree sum'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

lazy 노드의 값을 자식 노드로 내리고, tree 노드 자식도 업데이트한다.

<ImageContainer>
  <Image
    src={pic6}
    alt='lazy segment tree sum'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

경로에 또 lazy 값이 있으므로 위와 마찬가지로 진행한다.

<ImageContainer>
  <Image
    src={pic7}
    alt='lazy segment tree sum'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

이제 경로에 lazy 값이 없으므로 구간 [4, 4]에 대한 값을 구할 수 있다.

## 구현

<CodeSelector names={['LazySegmentTree.js']} desc='ex3' />

```js showLineNumbers
class LazySegmentTree {
  constructor(arr) {
    this.arr = arr
    this.h = 1 << Math.ceil(Math.log2(arr.length))
    this.tree = new Array(this.h << 1).fill(0)
    this.lazy = new Array(this.h << 1).fill(0)
    this.init(1, 0, this.h - 1)
  }

  init(node, start, end) {
    if (start === end) {
      this.tree[node] = this.arr[start] ?? 0
    } else {
      const mid = (start + end) >> 1
      this.init(node << 1, start, mid)
      this.init((node << 1) | 1, mid + 1, end)
      this.tree[node] = this.tree[node << 1] + this.tree[(node << 1) | 1]
    }
  }

  // [a, b]를 담당하는 node에서 아래로 전파한다.
  propagate(node, a, b) {
    if (this.lazy[node] === 0) return
    const mid = (a + b) >> 1
    this.tree[node << 1] += (mid - a + 1) * this.lazy[node]
    this.lazy[node << 1] += this.lazy[node]
    this.tree[(node << 1) | 1] += (b - mid) * this.lazy[node]
    this.lazy[(node << 1) | 1] += this.lazy[node]
    this.lazy[node] = 0
  }

  // [a, b]를 x만큼 증가시킨다.
  update(a, b, x, node = 1, start = 0, end = this.h - 1) {
    if (b < start || end < a) return
    if (a <= start && end <= b) {
      this.tree[node] += (end - start + 1) * x
      this.lazy[node] += x
      return
    }
    this.propagate(node, start, end)
    const mid = (start + end) >> 1
    this.update(a, b, x, node << 1, start, mid)
    this.update(a, b, x, (node << 1) | 1, mid + 1, end)
    this.tree[node] = this.tree[node << 1] + this.tree[(node << 1) | 1]
  }

  // [a, b]의 합을 구한다.
  sum(a, b, node = 1, start = 0, end = this.h - 1) {
    if (b < start || end < a) return 0
    if (a <= start && end <= b) return this.tree[node]

    this.propagate(node, start, end)
    const mid = (start + end) >> 1
    return this.sum(a, b, node << 1, start, mid) + this.sum(a, b, (node << 1) | 1, mid + 1, end)
  }
}
```
