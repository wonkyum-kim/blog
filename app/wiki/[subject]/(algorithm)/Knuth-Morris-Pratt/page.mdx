import { CodeSelector } from '@/components/code-selector.tsx'
import { ImageContainer } from '@/components/image-container/image-container.tsx'
import Image from 'next/image'
import pic1 from '/public/Algorithm/kmp1.jpg'
import pic2 from '/public/Algorithm/kmp2.jpg'
import pic3 from '/public/Algorithm/kmp3.jpg'
import pic4 from '/public/Algorithm/kmp4.jpg'
import pic5 from '/public/Algorithm/kmp5.jpg'
import pic6 from '/public/Algorithm/kmp6.jpg'
import pic7 from '/public/Algorithm/kmp7.jpg'
import pic8 from '/public/Algorithm/kmp8.jpg'

## KMP 알고리즘

`KMP 알고리즘`은 문자열 S에서 문자열 T가 존재하는지 찾는다.

브루트포스 방법으로는 $O(nm)$ 시간이 걸리지만, KMP 알고리즘을 사용하면 $O(n+m)$ 시간으로 찾을 수 있다.

## 실패 함수

KMP를 구현하기 위해서 먼저 `실패 함수`라는 것을 작성해야한다.

왜 실패 함수라는 이름이 붙었을까?

실패 함수는 단순히 `pi 배열`을 반환하는 함수이며, pi 배열은 문자의 비교가 실패했을 때(즉, 문자가 서로 다를 때) 사용되기 때문이다.

아직까지 감이 잘 오지는 않겠지만 일단 pi 배열이 무엇인지 살펴보자.

pi 배열이란, 부분문자열 t[0, i]의 접두사와 접미사가 같을 때 최대 길이를 저장하는 배열이다. (단, 접두사와 접미사는 전체 문자열이 될 수 없다고 가정한다.)

예를 들어, 'abcab'의 접두사 = 접미사인 문자열의 'ab'이며 길이는 2다.

브루트포스로 pi 배열을 구하는 것은 쉽지만, 이것을 $O(m)$ 시간에 구하는 방법에 대해 알아보자. ($m$은 t의 길이)

예를 들어 'ababaca'의 pi배열을 구하는 과정은 아래와 같다.

### t[0, 0] = 'a'

길이가 1이므로 바로 pi[0] = 0으로 설정한다.

### t[0, 1] = 'ab'

접두사는 'a'만 가능하고 접미사는 'b'만 가능하다. 둘이 같지 않으므로 pi[1] = 0으로 설정한다.

<ImageContainer>
  <Image
    src={pic1}
    alt='pi array'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

### t[0, 2] = 'aba'

접두사는 'a', 'ab'가 가능하고, 접미사는 'ba', 'a'가 가능하다.

가능한 접두사-접미사 쌍은 ['a', 'ba'], ['a', 'a'], ['ab', 'ba'], ['ab', 'a']로 총 2 \* 2 = 4가지가 나온다.

사실 우리가 관심있는 것은 접두사와 접미사의 길이가 같은 것이므로 ['a', 'a'], ['ab', 'ba']만 살펴보면 된다.

['<b>a</b>b', '<b>b</b>a']를 생각해보면 이미 이전 단계에서 앞 글자가 불가능하다고 판단했기 때문에 볼 필요가 없다는 것을 알 수 있다.

['a', 'a']는 서로 같으므로 pi[2] = 1이 된다.

<ImageContainer>
  <Image
    src={pic2}
    alt='pi array'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

### t[0, 3] = 'abab'

이전 단계에서 1글자(a)가 서로 같음을 확인했으니까 여기서 더 늘릴 수 있는지를 보면 된다.

b가 같아서 접두사, 접미사를 'ab'로 만들 수 있으므로 pi[3] = 2로 설정한다.

<ImageContainer>
  <Image
    src={pic3}
    alt='pi array'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

### t[0, 4] = 'ababa'

이전 단계에서 'ab'가 같다고 확인했으니까 더 늘려서 같은지 확인하면 된다.

마지막 글자(a)가 같으므로 늘릴 수 있고, pi[4] = 3이 된다.

<ImageContainer>
  <Image
    src={pic4}
    alt='pi array'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

### t[0, 5] = 'ababac'

이전 단계에서 'aba'가 같다고 확인했으니까 더 늘려서 같은지 확인하면 된다.

그런데 마지막 글자(c와 b)가 서로 다르다.

즉, t[0, 5] 부터는 'aba'를 늘려서 재사용할 수 없는 상황이 발생했다.

이제 한 가지 새로운 아이디어를 사용한다.

**문자열의 접두사의 접두사는 접두사고, 문자열의 접미사의 접미사도 접미사다.**

t[0, 4] = 'ababa'까지 접두사 = 접미사가 되는 최대 길이의 문자열은 'aba'였다.

'aba'의 접두사 = 접미사가 되는 최대 길이의 문자열은 'a'이며 위 아이디어에 따라서 'a'도 'ababa'의 접두사, 접미사가 된다.

그리고 이것은 이미 pi[2]에서 구해둔 값이라는 것을 알 수 있다.

이제 t[0, 4] = 'ababa'에서 두 번째로 긴 접두사 = 접미사가 되는 문자열인 'a'를 재사용하도록 변경한다.

<ImageContainer>
  <Image
    src={pic5}
    alt='pi array'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

### t[0, 5] = 'ababac'

이전 단계에서 'a'가 같다고 확인했으니까 더 늘려서 같은지 확인하면 된다.

그런데 여전히 마지막 글자(c와 b)가 서로 다르다.

<ImageContainer>
  <Image
    src={pic6}
    alt='pi array'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

마찬가지 논리로 'a'의 접두사 = 접미사 중 최대 길이의 문자열을 구하면 pi[0] = 0이므로 없는 것을 확인할 수 있다.

더 이상 접두사 = 접미사인 문자열이 없으므로 이제 재사용 할 것도 없어서 pi[5] = 0이라는 것을 알 수 있다.

즉, 비교가 실패했을 때 pi 배열을 통해 접두사의 접두사의 접두사...를 찾다가 더 이상 존재하지 않으면 그만 두는 것이다.

<ImageContainer>
  <Image
    src={pic7}
    alt='pi array'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

### t[0, 6] = 'ababaca'

이전 단계에서 접두사 = 접미사인 것이 없었으므로 새로 시작한다.

'a'가 서로 같으므로 pi[6] = 1로 설정한다.

<ImageContainer>
  <Image
    src={pic8}
    alt='pi array'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

이를 코드로 작성하면 아래와 같다.

<CodeSelector names={['failure function']} desc='failure' />

```js
function failure(t) {
  const n = t.length
  const pi = new Array(n).fill(0)
  let j = 0
  for (let i = 1; i < n; ++i) {
    while (j > 0 && t[i] !== t[j]) j = pi[j - 1]
    if (t[i] === t[j]) pi[i] = ++j
  }
  return pi
}
```

## 문자열 제곱

문자열을 k번 이어 붙인 것을 문자열 제곱이라고 하자. (https://www.acmicpc.net/problem/4354)

실패 함수를 사용하여 문자열 s가 어떤 문자열 a의 n제곱일 때, 가장 길이가 작은 a를 찾을 수 있다.

a의 길이는 s.length - pi[s.length - 1]이며, n은 s.length / a.length가 된다.

(단, s.length % a.length === 0을 만족해야 한다.)

## KMP 함수

실패 함수로 구한 pi 배열로 t를 찾는다.

이 과정은 실패 함수와 비슷하게 진행되며, t가 등장하는 모든 위치를 찾을 수 있다.

<CodeSelector names={['KMP function']} desc='KMP' />

```js
function KMP(s, t) {
  const n = s.length
  const m = t.length
  const pi = failure(t)
  const index = []

  let j = 0
  for (let i = 0; i < n; ++i) {
    while (j > 0 && s[i] !== t[j]) j = pi[j - 1]
    if (s[i] !== t[j]) continue

    if (j === m - 1) {
      j = pi[j]
      index.push(i - m + 1)
    } else {
      j++
    }
  }

  // t가 s에서 나타나는 인덱스가 저장되어 있다.
  return index
}
```
