import { CodeSelector } from '@/components/code-selector.tsx'

## 세그먼트 트리

`세그먼트 트리`는 구간 질의를 처리하는 것과 배열의 원소를 갱신하는 것을 $O(\log n)$ 시간에 처리해주는 자료구조다.

세그먼트 트리는 이진 트리의 일종으로 내부 노드와 리프노드로 구분된다.

리프 노드는 원래 배열의 원소가 들어있으며, 내부 노드는 해당 구간의 연산을 처리한 값을 포함하고 있다.

세그먼트 트리의 원리는 임의의 구간 $[a, b]$를 부분 구간 $O(\log n)$개로 나누고 그에 해당하는 구간의 연산을 미리 저장해두는 것이다.

따라서 쿼리마다 필요한 노드의 전체 개수는 $O(\log n)$개가 된다.

세그먼트 트리에 제공하는 배열은 크기가 2의 거듭제곱이라고 가정한다. (2의 거듭제곱이 아니라면 2의 거듭제곱이 되도록 크기를 늘리고 0을 채워 넣는다.)

세그먼트 트리의 루트의 인덱스는 1부터 시작하며, 주어진 배열의 원소의 개수가 8이라면 내부 노드는 1부터 7까지가 되고, 리프 노드는 8부터 15가 된다.

<CodeSelector names={['SegmentTree.js']} desc='ex1' />

```js showLineNumbers {9,17,26-27}
// 합 세그먼트 트리
class SegmentTree {
  constructor(arr) {
    this.h = 1 << Math.ceil(Math.log2(arr.length))
    this.tree = new Array(this.h << 1).fill(0)

    for (let i = 0; i < arr.length; ++i) this.tree[this.h + i] = arr[i]
    for (let k = this.h - 1; k > 0; k--) {
      this.tree[k] = this.tree[k << 1] + this.tree[(k << 1) | 1]
    }
  }

  update(k, x) {
    k += this.h
    this.tree[k] += x
    for (k >>= 1; k >= 1; k >>= 1) {
      this.tree[k] = this.tree[k << 1] + this.tree[(k << 1) | 1]
    }
  }

  sum(a, b) {
    a += this.h
    b += this.h
    let ans = 0
    while (a <= b) {
      if ((a & 1) === 1) ans += this.tree[a++]
      if ((b & 1) === 0) ans += this.tree[b--]
      a = Math.floor(a / 2)
      b = Math.floor(b / 2)
    }
    return ans
  }
}
```

위 코드는 구간의 합을 구하는 세그먼트 트리다.

최솟값이나 최댓값이 필요하다면, 코드를 적절히 변경하면 된다.

## k번째 원소 찾기

합 세그먼트 트리에서 k번째 원소를 찾을 수 있다.

Counting sort처럼 각 정점에 집합에 존재하는 원소의 개수를 추가해주면 된다.

예를 들어 트리에 1이 3개 5가 2개 존재한다면, 4번째 원소는 5가 되는 것이다.

찾는 방법은 아래와 같다.

- 세그먼트 트리의 루트 노드보다 k가 크다면, 전체 정점의 개수보다 k가 더 크다는 의미다.
- 왼쪽 자식 정점이 k보다 같거나 크다면, 왼쪽 정점으로 이동한다.
- 왼쪽 자식 정점이 k보다 작다면, 오른쪽 자식 정점으로 이동하고 k에서 왼쪽 자식 정점 값을 빼준다.
- 현재 정점이 리프노드에 도달하면 멈춘다.

전체 살펴볼 노드는 최대 $\log n$개 이므로, $O(\log n)$시간이 걸리게 된다.

<CodeSelector names={['search.js']} desc='ex2' />

```js showLineNumbers
function search(x) => {
  if (seg.tree[1] < x) return -1
  let curr = 1
  while (curr * 2 < seg.tree.length) {
    const left = curr * 2
    const right = left + 1

    const y = seg.tree[left]
    if (y >= x) {
      curr = left
    } else {
      x -= y
      curr = right
    }
  }
  return curr - seg.h
}
```

## 레이지 세그먼트 트리

`레이지 세그먼트 트리`는 값의 변경을 구간 단위로 할 수 있게 해준다.

TODO

<CodeSelector names={['LazySegmentTree.js']} desc='ex3' />

```js showLineNumbers {18, 25, 37, 47, 56-57}
class LazySegmentTree {
  constructor(arr) {
    this.arr = arr
    this.h = 1 << Math.ceil(Math.log2(arr.length))
    this.tree = new Array(this.h << 1).fill(0)
    this.lazy = new Array(this.h << 1).fill(0)

    this.init(1, 0, arr.length - 1)
  }

  init(node, start, end) {
    if (start === end) {
      this.tree[node] = this.arr[start]
    } else {
      const mid = (start + end) >> 1
      this.init(node << 1, start, mid)
      this.init((node << 1) | 1, mid + 1, end)
      this.tree[node] = this.tree[node << 1] + this.tree[(node << 1) | 1]
    }
  }

  propagate(node, start, end) {
    if (this.lazy[node] === 0) return

    this.tree[node] += (end - start + 1) * this.lazy[node]
    if (start !== end) {
      this.lazy[node << 1] += this.lazy[node]
      this.lazy[(node << 1) | 1] += this.lazy[node]
    }
    this.lazy[node] = 0
  }

  update(left, right, x, node = 1, start = 0, end = this.arr.length - 1) {
    this.propagate(node, start, end)
    if (left > end || right < start) return
    if (left <= start && end <= right) {
      this.tree[node] += (end - start + 1) * x
      if (start !== end) {
        this.lazy[node << 1] += x
        this.lazy[(node << 1) | 1] += x
      }
      return
    }
    const mid = (start + end) >> 1
    this.update(left, right, x, node << 1, start, mid)
    this.update(left, right, x, (node << 1) | 1, mid + 1, end)
    this.tree[node] = this.tree[node << 1] + this.tree[(node << 1) | 1]
  }

  sum(left, right, node = 1, start = 0, end = this.arr.length - 1) {
    this.propagate(node, start, end)
    if (left > end || right < start) return 0
    if (left <= start && end <= right) return this.tree[node]
    const mid = (start + end) >> 1
    return (
      this.sum(left, right, node << 1, start, mid) +
      this.sum(left, right, (node << 1) | 1, mid + 1, end)
    )
  }
}
```
