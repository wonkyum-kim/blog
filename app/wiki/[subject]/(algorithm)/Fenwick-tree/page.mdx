import { CodeSelector } from '@/components/code-selector.tsx'

## 펜윅 트리

펜윅 트리는 원소의 업데이트와 구간의 누적 합을 구할 수 있는 트리다.

펜윅 트리가 세그먼트 트리와 다른 점은 사용하는 노드의 개수가 더 적다는 것이다.

예를 들어 원래 배열의 길이가 8이라면 세그먼트 트리의 노드의 개수는 15개가 필요하고, 펜윅 트리는 8개의 노드가 필요하다.

그 이유는 부모 노드와 왼쪽 자식 노드만 가지고도 누적 합을 구하는데 문제가 없기 때문이다.

펜윅 트리의 각 노드 `tree[k]`는 k를 포함하여 k의 약수 중 가장 큰 2의 거듭제곱개의 원소의 합을 관리한다.

즉, tree[k]가 관리하는 원소의 개수를 x라 하면, sum[k - x + 1, k]를 가지고 있는 것이다.

<CodeSelector names={['fenwick.js']} desc='fwt' />

```js
class FenwickTree {
  constructor(n) {
    this.n = n
    this.tree = new Array(this.n + 1).fill(0)
  }

  update(k, x) {
    while (k <= this.n) {
      this.tree[k] += x
      // k & -k : k의 비트 중에서 최하위 비트 한 개만을 남긴다.
      // e.g. k가 6일 때, k = 0000 0110, -k = 1111 1010 -> k & -k = 0000 0010
      k += k & -k
    }
  }

  // [1, k]까지의 합
  sum(k) {
    let sum = 0
    while (k >= 1) {
      sum += this.tree[k]
      k -= k & -k
    }
    return sum
  }
}
```

## 2D 펜윅 트리

2차원으로 확장시킬 수 있다.

<CodeSelector names={['fenwick2d.js']} desc='fwt2' />

```js
class FenwickTree2D {
  constructor(n, m) {
    this.n = n
    this.m = m
    this.tree = array2d(n + 1, m + 1)
  }

  // (y, x)에 k를 더한다.
  update(y, x, k) {
    for (let i = y; i <= this.n; i += i & -i) {
      for (let j = x; j <= this.m; j += j & -j) {
        this.tree[i][j] += k
      }
    }
  }

  // [1, 1] ~ [y, x] 까지의 합
  sum(y, x) {
    let ans = 0
    for (let i = y; i > 0; i -= i & -i) {
      for (let j = x; j > 0; j -= j & -j) {
        ans += this.tree[i][j]
      }
    }
    return ans
  }
}
```
