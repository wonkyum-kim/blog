import { CodeSelector } from '@/components/code-selector.tsx'
import { ImageContainer } from '@/components/image-container/image-container.tsx'
import Image from 'next/image'
import pic1 from '/public/Algorithm/seg1.jpg'
import pic2 from '/public/Algorithm/fen1.jpg'
import pic3 from '/public/Algorithm/fen2.jpg'

## 펜윅 트리

펜윅 트리는 원소의 업데이트와 구간의 누적 합을 구할 수 있는 트리다.

펜윅 트리는 첫 번째 원소부터의 누적 합만을 저장하므로, 세그먼트 트리보다 사용하는 노드의 개수가 더 적다.

아래는 합 세그먼트 트리를 나타낸 것이다.

<ImageContainer>
  <Image
    src={pic1}
    alt='segment tree'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

여기서 첫 번째 원소부터 k번째 원소까지의 누적 합만을 구한다고 한다면, 아래와 같은 노드만을 사용하면 된다.

<ImageContainer>
  <Image
    src={pic2}
    alt='fenwick tree'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

사용하지 않는 노드를 지우면 아래와 같은 배열이 만들어진다.

<ImageContainer>
  <Image
    src={pic3}
    alt='fenwick tree'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

펜윅 트리의 각 노드 tree[k]는 k를 포함하여 k의 약수 중 가장 큰 2의 거듭제곱 개의 원소의 합을 관리한다.

즉, tree[k]가 관리하는 원소의 개수를 x라 하면, sum(k - x + 1, k)를 가지고 있는 것이다.

x를 찾는 가장 쉬운 방법은 k의 가장 낮은 비트를 찾는 것이다.

k의 최하위 비트만 남기고 나머지를 0으로 만든 수 x는 k의 약수 중 가장 큰 2의 거듭제곱인 수가 된다.

이것은 간단한 비트 연산 k & -k로 찾을 수 있다.

## 구현

### 1차원 펜윅 트리

<CodeSelector names={['fenwick.js']} desc='fwt' />

```js
class FenwickTree {
  constructor(n) {
    this.n = n
    this.tree = new Array(this.n + 1).fill(0)
  }

  // k번째 원소를 x만큼 증가시킨다.
  update(k, x) {
    while (k <= this.n) {
      this.tree[k] += x
      k += k & -k
    }
  }

  // [1, k]까지의 합
  sum(k) {
    let sum = 0
    while (k >= 1) {
      sum += this.tree[k]
      k -= k & -k
    }
    return sum
  }
}
```

### 2차원 펜윅 트리

<CodeSelector names={['fenwick2d.js']} desc='fwt2' />

```js
class FenwickTree2D {
  constructor(n, m) {
    this.n = n
    this.m = m
    this.tree = array2d(n + 1, m + 1)
  }

  // (y, x)에 k를 더한다.
  update(y, x, k) {
    for (let i = y; i <= this.n; i += i & -i) {
      for (let j = x; j <= this.m; j += j & -j) {
        this.tree[i][j] += k
      }
    }
  }

  // [1, 1] ~ [y, x] 까지의 합
  sum(y, x) {
    let ans = 0
    for (let i = y; i > 0; i -= i & -i) {
      for (let j = x; j > 0; j -= j & -j) {
        ans += this.tree[i][j]
      }
    }
    return ans
  }
}
```
