import { CodeSelector } from '@/components/code-selector.tsx'
import { ImageContainer } from '@/components/image-container/image-container.tsx'
import Image from 'next/image'
import pic1 from '/public/Algorithm/aho1.jpg'
import pic2 from '/public/Algorithm/aho2.jpg'
import pic3 from '/public/Algorithm/aho3.jpg'
import pic4 from '/public/Algorithm/aho4.jpg'
import pic5 from '/public/Algorithm/aho5.jpg'
import pic7 from '/public/Algorithm/aho7.jpg'
import pic9 from '/public/Algorithm/aho9.jpg'
import pic11 from '/public/Algorithm/aho11.jpg'
import pic14 from '/public/Algorithm/aho14.jpg'
import pic15 from '/public/Algorithm/aho15.jpg'
import pic16 from '/public/Algorithm/aho16.jpg'
import pic18 from '/public/Algorithm/aho18.jpg'
import pic19 from '/public/Algorithm/aho19.jpg'

## 아호 코라식 알고리즘

`아호 코라식`은 주어진 문자열 집합(딕셔너리라고 한다.) W와 문자열 S가 있을 때, S의 부분문자열 중에 W에 속한 문자열이 있는지 찾는 알고리즘이다.

아호 코라식은 `KMP`와 `트라이`를 사용하여 $O(n + w_1 + w_2 + \cdots + w_k + m)$ 시간에 작동한다. ($n$은 S의 길이, $w_i$는 W[i]의 길이, $m$은 매칭된 횟수)

## 트라이

먼저 주어진 딕셔너리 W = ['a', 'ab', 'bab', 'bc', 'bca', 'c', 'caa']에 있는 문자열들로 `트라이`를 만든다.

딕셔너리에 있는 모든 문자열의 모든 접두사가 트라이의 노드로 존재한다.

예를 들어, 'bca'가 딕셔너리에 있으므로 'bca', 'bc', 'b', ''에 해당하는 노드가 존재한다.

딕셔너리에 있는 문자열에 해당하는 노드(e.g. 'bca')는 진한 색으로 표시하였다.

<ImageContainer>
  <Image
    src={pic1}
    alt='aho'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

## 접미사 간선과 딕셔너리 접미사 간선

아호 코라식 알고리즘을 사용하기 위해서는 트라이에 `접미사 간선`과 `딕셔너리 접미사 간선`을 만들어줘야 한다.

빨간색의 `접미사 간선`은 각 노드에서 그래프에서 가능한 가장 긴 **엄격한 접미사** 노드로 향한다. (엄격한 접미사란, 전체 문자열을 제외한 접미사를 말한다.)

예를 들어, 'caa'에 해당하는 노드는 엄격한 접미사로 'aa', 'a', ''를 가진다.

그래프에 존재하는 가장 긴 엄격한 접미사는 'a' 이므로, 'caa'에서 'a'로 접미사 간선이 존재한다.

접미사 간선은 루트에서 bfs를 실행하여 선형 시간에 계산할 수 있다.

어떤 노드의 접미사 간선이 향하는 노드는 부모 노드의 접미사 간선을 따라 도착한 가장 긴 **접미사 노드**에서 현재 노드의 문자와 일치하는 문자를 가진 **접미사 노드의 자식**을 검색하여 찾을 수 있다.

접미사 노드의 자식 노드에 해당 문자가 존재하지 않으면, 다시 접미사 간선을 따라가면서 그 다음으로 긴 접미사를 찾은 다음 해당 문자를 찾는다.

이 과정은 접미사 간선을 따라가서 만난 노드의 자식 노드가 방문한 노드의 문자와 일치하거나 루트에 도달할 때까지 반복된다.

파란색 `딕셔너리 접미사 간선`은 각 노드에서 접미사 간선을 타고 처음 만나는 딕셔너리에 있는 노드로 향한다.

이제 실제로 접미사 간선과 딕셔너리 접미사 간선을 만드는 과정을 살펴보자.

현재 정점이 0번 정점일 때, 1, 3, 8번 정점과 연결되어 있다.

'a', 'b', 'c'에서 가장 긴 엄격한 접미사는 ''이므로 루트와 연결하는 접미사 간선을 만든다.

<ImageContainer>
  <Image
    src={pic2}
    alt='aho'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

<ImageContainer>
  <Image
    src={pic3}
    alt='aho'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

<ImageContainer>
  <Image
    src={pic4}
    alt='aho'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

현재 정점이 1번, 다음 정점이 2번, 현재 정점의 접미사 정점이 0번일 때, 0번의 자식 중에서 'b'에 해당하는 노드는 3번 이므로 2->3 접미사 간선을 만든다.

이것은 'ab'의 엄격한 접미사 중에 방문한 노드 중에서 가장 긴 것이 'b'라는 의미다.

<ImageContainer>
  <Image
    src={pic5}
    alt='aho'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

현재 정점이 3번, 다음 정점이 4번, 현재 정점의 접미사 정점이 0번일 때, 0번의 자식 중에서 'a'에 해당하는 노드는 1번이므로 4->1 접미사 간선을 만든다.

4번에서 접미사 간선을 타고 만날 수 있는 노드 중에서 딕셔너리에 존재하는 노드는 1번이 처음이다.

따라서 4->1 딕셔너리 접미사 간선을 만든다.

<ImageContainer>
  <Image
    src={pic7}
    alt='aho'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

현재 정점이 3번, 다음 정점이 6번, 현재 정점의 접미사 정점이 0번일 때, 0번의 자식 중에서 'c'에 해당하는 노드는 8번이므로 6->8 접미사 간선을 만든다.

6번에서 접미사 간선을 타고 만날 수 있는 노드 중에서 딕셔너리에 존재하는 노드는 8번이 처음이다.

따라서 6->8 딕셔너리 접미사 간선을 만든다.

<ImageContainer>
  <Image
    src={pic9}
    alt='aho'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

현재 정점이 8번, 다음 정점이 9번, 현재 정점의 접미사 정점이 0번일 때, 0번의 자식 중에서 'a'에 해당하는 노드는 1번이므로 9->1 접미사 간선을 만든다.

9번에서 접미사 간선을 타고 만난 수 있는 노드 중에서 딕셔너리에 존재하는 노드는 1번이 처음이다.

따라서 9->1 딕셔너리 접미사 간선을 만든다.

<ImageContainer>
  <Image
    src={pic11}
    alt='aho'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

현재 정점이 2번일 때, 자식 노드가 없으므로 아무것도 하지 않고 넘어간다.

현재 정점이 4번, 다음 정점이 5번, 현재 정점의 접미사 정점이 1번일 때, 1번의 자식 중에서 'ab'에 해당하는 정점은 2번이므로 5->2 접미사 간선을 만든다.

5번에서 접미사 간선을 타고 만난 수 있는 노드 중에서 딕셔너리에 존재하는 노드는 2번이 처음이다.

따라서 5->2 딕셔너리 접미사 간선을 만든다.

<ImageContainer>
  <Image
    src={pic14}
    alt='aho'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

현재 정점이 6번, 다음 정점이 7번, 현재 정점의 접미사 정점이 8번일 때, 8번의 자식 중에서 'ca'에 해당하는 노드는 9번이므로 7->9 접미사 간선을 만든다.

7번에서 접미사 간선을 타고 만난 수 있는 노드 중에서 딕셔너리에 존재하는 노드는 1번이 처음이다.

따라서 7->1 딕셔너리 접미사 간선을 만든다.

<ImageContainer>
  <Image
    src={pic15}
    alt='aho'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

현재 정점이 9번, 다음 정점이 10번, 현재 정점의 접미사 정점이 1번일 때, 1번 정점은 'a'에 해당하는 정점을 자식으로 가지고 있지 않다.

<ImageContainer>
  <Image
    src={pic16}
    alt='aho'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

1번 정점에서 접미사 간선을 타고 0번 정점에 도달하면 0번 정점은 'a'에 해당하는 1번 정점을 자식으로 가지고 있으므로 10->1 접미사 간선을 만든다.

10번에서 접미사 간선을 타고 만난 수 있는 노드 중에서 딕셔너리에 존재하는 노드는 1번이 처음이다.

따라서 10->1 딕셔너리 접미사 간선을 만든다.

<ImageContainer>
  <Image
    src={pic18}
    alt='aho'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

이후 5번, 7번, 10번 정점은 자식 노드를 가지고 있지 않으므로 아무것도 하지 않고 종료한다.

## 문자열 찾기

문자열 S를 'abccab'라고 하자.

이제 S의 부분문자열 중에서 W에 속한 문자열이 있는지 찾아보도록 한다.

- S의 문자와 비교하면서 현재 정점의 자식 중에 값을 가지고 있는 정점으로 이동한다.
- 그런 자식 노드가 없으면 현재 노드의 실패 간선을 타고 계속 이동해서 찾아본다.
- 현재 정점이 문자열 패턴의 마지막 노드이면 W에 속한 문자열 중 하나를 발견한 것이다.
- 현재 정점에 성공 간선이 있으면 W에 속한 문자열 중 하나를 발견한 것이다.

<ImageContainer>
  <Image
    src={pic19}
    alt='aho'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

1. 0번에서 'a'를 값으로 가지고 있는 1번으로 이동한다. 'a'를 찾았다.
2. 1번에서 'b'를 값으로 가지고 있는 2번으로 이동한다. 'ab'를 찾았다.
3. 2번에서 'c'를 값으로 가지고 있는 자식이 없다. 접미사 간선을 타고 3번으로 이동한다.
4. 3번에서 'c'를 값으로 가지고 있는 6번으로 이동한다. 'bc'를 찾았다. 6번은 딕셔너리 접미사 간선도 가지고 있으므로 8번 노드에 해당하는 'c'도 찾았다.
5. 6번에서 'c'를 값으로 가지고 있는 자식이 없다. 접미사 간선을 타고 8번으로 이동한다.
6. 8번에서 'c'를 값으로 가지고 있는 자식이 없다. 접미사 간선을 타고 0번으로 이동한다.
7. 0번에서 'c'를 값으로 가지고 있는 8번으로 이동한다. 'c'를 찾았다.
8. 8번에서 'a'를 값으로 가지고 있는 9번으로 이동한다. 9번의 딕셔너리 접미사 간선을 타면 1번 노드에서 'a'를 찾을 수 있다.
9. 9번에서 'b'를 값으로 가지고 있는 자식이 없다. 1번으로 이동한다.
10. 1번에서 'b'를 값으로 가지고 있는 2번으로 이동한다. 'ab'를 찾았다.

## 구현

구현은 아래처럼 객체를 이용한 방식도 있고, 문자의 범위를 안다면(e.g. 소문자 26개) 배열을 사용할 수도 있다.

메모리 초과나 시간 초과 여부에 따라서 적절한 방식을 선택해야 한다.

<CodeSelector names={['AhoCorasick']} desc='AhoCorasick' />

```js showLineNumbers
class Trie {
  constructor(arr) {
    this.tree = []
    this.newNode()
    for (let i = 0; i < arr.length; ++i) this.add(arr[i])
    this.bfs()
  }

  newNode() {
    const node = {
      child: {},
      suffix: null,
      dictSuffix: null,
      valid: null,
    }
    this.tree.push(node)
    return this.tree.length - 1
  }

  add(s) {
    let node = 0
    for (let i = 0; i < s.length; ++i) {
      if (!(s[i] in this.tree[node].child)) this.tree[node].child[s[i]] = this.newNode()
      node = this.tree[node].child[s[i]]
    }
    this.tree[node].valid = true
  }

  AhoCorasick(t) {
    let curr = 0
    const nodes = []
    for (const x of t) {
      if (x in this.tree[curr].child) {
        curr = this.tree[curr].child[x]
      } else {
        if (curr === 0) continue
        curr = this.tree[curr].suffix
        while (curr && !(x in this.tree[curr].child)) curr = this.tree[curr].suffix
        curr = this.tree[curr].child[x] ?? 0
      }
      if (this.tree[curr].valid) nodes.push(curr)
      if (this.tree[curr].dictSuffix) nodes.push(this.tree[curr].dictSuffix)
    }
    return nodes
  }

  bfs() {
    const q = new Queue()
    q.push(0)
    while (!q.empty()) {
      const curr = q.front()
      q.pop()
      for (const key in this.tree[curr].child) {
        const next = this.tree[curr].child[key]

        if (curr === 0) this.tree[next].suffix = curr
        else {
          let suffix = this.tree[curr].suffix
          while (suffix > 0 && !this.tree[suffix].child[key]) suffix = this.tree[suffix].suffix
          const suffixChild = this.tree[suffix].child[key] ?? 0

          // suffix edge
          this.tree[next].suffix = suffixChild
          // dictionary suffix edge
          this.tree[next].dictSuffix = this.tree[suffixChild].valid
            ? suffixChild
            : this.tree[suffixChild].dictSuffix
        }
        q.push(next)
      }
    }
  }
}

const W = ['a', 'ab', 'bab', 'bc', 'bca', 'c', 'caa']
const S = 'abccab'
const trie = new Trie(W)
const nodes = trie.AhoCorasick(S)
console.log(nodes) // [1, 2, 6, 8, 8, 1, 2]
```

## References

- https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm
