import { CodeSelector } from '@/components/code-selector.tsx'

## 최대 유량(Maximum flow)

최대 유량 문제는 소스에서 싱크로 흐르는 유량을 최대한으로 만드는 방법을 찾는다.

`소스(source)`는 들어오는 간선이 없는 노드이고, `싱크(sink)`는 나가는 간선이 없는 노드다.

노드 u에서 노드 v로 가는 간선이 존재하고 이 간선의 `용량(capacity)`이 w일 때, 간선을 통해 이동하는 `유량(flow)`을 k라고 하면 k는 최대 w가 될 수 있다.

소스와 싱크를 제외한 각 노드에서는 들어오는 유량과 나가는 유량은 같아야 한다.

코드로 구현할 때에는 유량을 따로 관리하지는 않고 용량만을 감소시키거나 증가시키면서 현재 흐른 유량을 제외하고 남은 용량을 관리한다.

## 포드-풀커슨(Ford-Fulkerson) 방법

최대 유량을 찾는 방법으로 `포드-풀커슨 방법`이 있다.

알고리즘이라고 하지 않고 방법이라고 하는 이유는 구체적으로 경로를 찾는 방법을 제시하지는 않고 일반적인 이야기만을 하기 때문이다.

1. 간선마다 반대 방향의 간선을 추가하고 정방향 간선의 가중치는 간선의 용량, 반대 방향의 간선의 가중치는 0으로 설정한다.
2. 각 단계마다 소스에서 싱크로 가는 경로 중 모든 간선이 0보다 큰 용량을 가지는 경로를 고른다. (증가 경로가 여러가지라면 어떤 것을 선택해도 된다.) 이 경로를 `증가 경로(augmenting path)`라고 한다.
3. 경로에 속한 간선들의 용량들 중 가장 작은 값을 x라고 한다면, 유량을 최대 x만큼 흘려보낼 수 있다는 의미가 된다. 경로에 속한 모든 간선의 용량을 x만큼 감소시키고, 그 간선의 역방향 간선들의 용량을 x만큼 증가시킨다.
4. 더 이상 증가 경로를 찾을 수 없을 때까지 반복한다.

1번에서 역방향 간선을 추가하고 3번에서 역방향 간선의 용량을 증가시키는 이유는 [여기](https://m.blog.naver.com/PostView.naver?blogId=kks227&logNo=220804885235&navType=by)에 나와있다.

간단히 얘기하면, 이미 흘려버린 유량 중 일부분을 다시 돌려보내서 다른 곳으로 흐르도록 만들기 위함이다.

2번에서 증가 경로를 찾는 방식에 따라서 알고리즘의 성능이 좌우된다.

## 에드몬드-카프(Edmonds-Karp) 알고리즘

`에드몬드-카프 알고리즘`은 증가 경로를 BFS로 찾는 포드-풀커슨 방법으로 $O(m^{2}n)$ 시간이 걸린다.

## 용량 조절(Capacity scaling) 알고리즘

`용량 조절 알고리즘`은 기준 값(delta)을 간선의 용량 중 가장 큰 값보다 같거나 큰 최소의 2의 거듭제곱으로 설정하며, delta 보다 작은 용량을 가진 간선을 제외한 그래프를 사용하여 최대 유량을 찾는다.

증가 경로를 찾을 수 없는 경우 delta를 2로 나누는 것을 반복하며, 0이 되면 알고리즘을 종료한다.

이 알고리즘은 dfs를 사용할 수 있고, $O(m^{2} \log{c})$ 시간이 걸린다. (c는 초기 delta 값)

<CodeSelector names={['17412.js']} desc='ex1' />

```js
// 백준 17412번

let [n, m] = [0, 0].map(() => input.getNumber)
const adj = array2d(n, 0)
const parent = new Array(n).fill(-1)
const visited = new Array(n).fill(false)
const id = new Array(n).fill(-1)

// delta 보다 작은 용량을 가진 간선을 지운다.
function dfs(curr, sink, delta) {
  visited[curr] = true
  if (curr === sink) return true
  for (let i = 0; i < adj[curr].length; ++i) {
    const [next, index, capacity] = adj[curr][i]
    if (visited[next]) continue
    if (capacity < delta) continue
    parent[next] = curr
    id[curr] = i
    if (dfs(next, sink, delta)) return true
  }
  return false
}

function clear() {
  parent.fill(-1)
  visited.fill(false)
  id.fill(-1)
  return true
}

function capacityScaling(source, sink) {
  // 간선의 최대 용량으로 설정한다.
  // 이 문제에서는 1로 설정해도 된다.
  let maxCapacity = 1
  let maxFlow = 0

  for (let delta = maxCapacity; delta > 0; delta >>= 1) {
    // delta 이상의 flow를 가진 augmenting path를 모두 찾는다.
    while (clear() && dfs(source, sink, delta)) {
      let pathFlow = Infinity

      // 경로에서 가장 작은 flow를 찾는다.
      for (let v = sink; v != source; v = parent[v]) {
        const u = parent[v]
        pathFlow = Math.min(pathFlow, adj[u][id[u]][2])
      }

      // 정방향 간선의 용량은 줄이고 역방향 간선의 용량은 늘린다.
      for (let v = sink; v != source; v = parent[v]) {
        const u = parent[v]
        const uvi = id[u]
        const vui = adj[u][id[u]][1]
        adj[u][uvi][2] -= pathFlow
        adj[v][vui][2] += pathFlow
      }

      maxFlow += pathFlow
    }
  }
  return maxFlow
}

function solve() {
  while (m--) {
    const [a, b] = [0, 0].map(() => input.getNumber - 1)
    // 반대편 정점, 반대편 간선의 인덱스, 용량
    adj[a].push([b, adj[b].length, 1])
    adj[b].push([a, adj[a].length - 1, 0])
  }

  console.log(capacityScaling(0, 1))
}

solve()
```

## 디닉(Dinic's) 알고리즘

에드몬드-카프 알고리즘이 $O(m^{2}n)$시간, 용량 조절 알고리즘이 $O(m^{2} \log{c})$시간 걸리는 것에 비해 `디닉 알고리즘`은 $O(mn^{2})$시간으로 더 빠르게 작동한다.

사실상 앞의 두 알고리즘의 상위 호환이므로 디닉 알고리즘만 알고있어도 무방하다.

디닉 알고리즘은 `레벨 그래프`를 먼저 만들고 소스에서 싱크로 도달할 수 있는지 먼저 판단한다.

- 소스에서부터 bfs를 시작했을 때 다음 노드의 레벨은 이전 노드의 레벨 + 1이 된다.
- 이때 간선의 용량이 0이라면 다음 노드로 이동할 수 없다.

소스에서부터 인접한 정점 중 레벨이 정확히 1 큰 곳으로 이동하면서 유량을 찾는 것을 반복한다.

<CodeSelector names={['Dinic.js']} desc='ex2' />

```js
class Dinic {
  constructor(size, source, sink) {
    this.adj = array2d(size, 0)
    this.level = new Array(size).fill(-1)
    this.work = new Array(size).fill(0)
    this.source = source
    this.sink = sink
  }

  makeEdge(a, b, cap) {
    const forward = { next: b, inv: this.adj[b].length, residual: cap }
    // 양방향 간선이라면 residual을 cap으로 수정한다.
    const reverse = { next: a, inv: this.adj[a].length, residual: 0 }
    this.adj[a].push(forward)
    this.adj[b].push(reverse)
  }

  // 레벨 그래프를 만든다.
  bfs() {
    this.level.fill(-1)
    this.level[this.source] = 0
    const q = new Queue()
    q.push(this.source)

    while (!q.empty()) {
      const curr = q.front()
      q.pop()
      for (const { next, residual } of this.adj[curr]) {
        if (this.level[next] === -1 && residual > 0) {
          this.level[next] = this.level[curr] + 1
          q.push(next)
        }
      }
    }
    return this.level[this.sink] !== -1
  }

  // 레벨 그래프에서 flow를 구한다.
  dfs(curr, total) {
    if (curr === this.sink) return total

    for (; this.work[curr] < this.adj[curr].length; this.work[curr]++) {
      const edge = this.adj[curr][this.work[curr]]
      const { next, inv, residual } = edge

      if (this.level[next] === this.level[curr] + 1 && residual > 0) {
        const flow = this.dfs(next, Math.min(total, residual))
        if (flow > 0) {
          edge.residual -= flow
          this.adj[next][inv].residual += flow
          return flow
        }
      }
    }
    return 0
  }

  maxFlow() {
    let totalFlow = 0

    while (this.bfs()) {
      this.work.fill(0)
      let flow
      while ((flow = this.dfs(this.source, Infinity)) > 0) {
        totalFlow += flow
      }
    }

    return totalFlow
  }
}
```

## 간선 서로소 경로

소스에서 싱크로 가는 경로 중 각 간선이 최대 하나의 경로에만 포함되는 것을 찾을 수 있다.

간선의 가중치를 1로 설정하면 최대 유량이 경로의 개수가 된다.

도시 왕복하기 1: https://www.acmicpc.net/problem/17412

## 노드 서로소 경로

소스에서 싱크로 가는 경로 중 각 노드가 최대 하나의 경로에만 포함되는 것을 찾을 수 있다. (소스와 싱크는 제외)

노드를 in과 out 2개로 분할하고 그 사이를 잇는 간선의 가중치를 1로 두면 최대 유량이 경로의 개수가 된다. (간선 서로소 경로처럼 기존 간선의 가중치를 1로 두는 것은 같다.)

도시 왕복하기 2 https://www.acmicpc.net/problem/2316
