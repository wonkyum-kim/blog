import { CodeSelector } from '@/components/code-selector.tsx'
import { ImageContainer } from '@/components/image-container/image-container.tsx'
import Image from 'next/image'
import pic1 from '/public/Algorithm/sa1.jpeg'
import pic2 from '/public/Algorithm/sa2.jpeg'
import pic3 from '/public/Algorithm/sa3.jpeg'

## 접미사 배열

문자열의 접미사 배열은 문자열의 모든 접미사들을 사전 순으로 정렬해둔 것이다.

문자열을 `s`, i 위치 문자부터 t 개의 문자로 이루어진 부분 문자열을 `s[i..t]`라고 한다.

접미사 배열 `sa`는 접미사가 사전 순으로 정렬되었을 때, 정렬된 배열에서 i 번째 위치에 있는 접미사가 `s[sa[i]..]`임을 나타낸다.

그리고 접미사가 사전 순으로 정렬되었을 때, 정렬된 배열에서 `s[sa[i]..]`의 등수를 `rank[sa[i]] >= 1`로 표현한다.

mississipi의 접미사들을 구해보면 아래와 같다.

왼쪽은 정렬되기 이전의 모습이고, 오른쪽은 정렬된 모습이다.

<ImageContainer>
  <Image
    src={pic1}
    alt='sa'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

접미사 배열 sa를 구하는 방법은 IOI KOREA 유튜브(https://www.youtube.com/watch?v=qJ_ft3Spcxc&t=236s) 에 잘 설명되어 있으니 참고하도록 한다.

대략적으로 설명하면 아래와 같이 문자열의 길이를 2배씩 늘려가면서 앞 문자열과 뒤 문자열의 등수를 가져와 새로운 등수를 만드는 것이다.

(원래 이 과정마다 정렬을 진행해야 하지만 설명을 편하게 하기 위해서 정렬은 하지 않았다.)

<ImageContainer>
  <Image
    src={pic2}
    alt='sa'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

<ImageContainer>
  <Image
    src={pic3}
    alt='sa'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

### $O(n{\log^{2}{n}})$ 구현

$\log{n}$번 동안 $n\log{n}$번 정렬하므로 $O(n{\log^{2}{n}})$시간이 걸린다.

<CodeSelector names={['index.js']} desc='ex1' />

```js showLineNumbers
function suffixArray(str) {
  const n = str.length
  const sa = new Array(n).fill(0)
  const rank = new Array(n + 1).fill(0)
  const temp = new Array(n + 1).fill(0)

  // 아스키코드를 등수로 변환한다. (소문자 기준)
  const check = new Array(26).fill(0)
  // 등장한 문자에 표시를 해둔다.
  for (let i = 0; i < n; ++i) check[str.charCodeAt(i) - 'a'.charCodeAt()] = 1
  // 각 문자마다 초기 등수를 설정한다.
  for (let i = 1; i < 26; ++i) check[i] += check[i - 1]
  for (let i = 0; i < n; ++i) {
    rank[i] = check[str.charCodeAt(i) - 'a'.charCodeAt()]
    sa[i] = i
  }

  for (let t = 1; t < n; t <<= 1) {
    // firstRank끼리 비교하고 같으면 backRank를 비교한다.
    const comp = (a, b) => {
      let rank1 = rank[a]
      let rank2 = rank[b]
      if (rank1 === rank2) {
        rank1 = a + t < n ? rank[a + t] : 0
        rank2 = b + t < n ? rank[b + t] : 0
      }
      return rank1 - rank2
    }
    sa.sort(comp)

    temp[sa[0]] = 1
    for (let i = 1; i < n; ++i) {
      temp[sa[i]] = temp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) < 0 ? 1 : 0)
    }

    for (let i = 0; i < n; ++i) rank[i] = temp[i]
  }

  return sa
}
```

### $O(n{\log{n}})$ 구현

counting sort를 하면 더 빠른 시간에 접미사 배열을 구할 수 있다.

이때, (frontRank, backRank)를 비교하여 정렬하기 위해서 stable sort가 필요하다.

stable sort는 같은 값이라면 처음 가진 순서를 유지한 상태를 유지해야 한다.

예를 들어 i가 3과 5에서 backRank가 서로 같다고 해보자.

frontRank가 서로 다르다면, 정렬할 때 3이 5보다 앞에 오는 것은 자명하다.

하지만 frontRank도 서로 같다면, 인덱스 순서에 따라서 3이 5보다 앞에 오도록 해야한다.

누적 합을 통해서 같은 값들이 존재하더라도 몇 번째 등수인지 알 수 있고, i를 뒤에서부터 살펴보면서 할당하므로 안정적인 정렬이 가능하다.

<CodeSelector names={['index.js']} desc='ex2' />

```js showLineNumbers
function suffixArray(str) {
  const n = str.length

  const sa = new Array(n).fill(0)
  const rank = new Array(n + 1).fill(0)
  const temp = new Array(n + 1).fill(0)

  const m = Math.max(27, n + 1)
  const count = new Array(m).fill(0)
  const idx = new Array(m).fill(0)

  // 아스키코드를 등수로 변환한다. (소문자 기준)
  const check = new Array(26).fill(0)
  // 등장한 문자에 표시를 해둔다.
  for (let i = 0; i < n; ++i) check[str.charCodeAt(i) - 'a'.charCodeAt()] = 1
  // 각 문자마다 초기 등수를 설정한다.
  for (let i = 1; i < 26; ++i) check[i] += check[i - 1]
  for (let i = 0; i < n; ++i) {
    rank[i] = check[str.charCodeAt(i) - 'a'.charCodeAt()]
    sa[i] = i
  }

  for (let t = 1; t < n; t *= 2) {
    const comp = (a, b) => {
      let rank1 = rank[a]
      let rank2 = rank[b]
      if (rank1 === rank2) {
        rank1 = a + t < n ? rank[a + t] : 0
        rank2 = b + t < n ? rank[b + t] : 0
      }
      return rank1 - rank2
    }

    for (let i = 0; i < m; ++i) count[i] = 0
    for (let i = 0; i < n; ++i) count[i + t < n ? rank[i + t] : 0]++
    for (let i = 1; i < m; ++i) count[i] += count[i - 1]
    // idx[x] = i:  s[i..t]의 backRank가 x번째이다.
    for (let i = n - 1; i >= 0; --i) idx[--count[i + t < n ? rank[i + t] : 0]] = i

    for (let i = 0; i < m; ++i) count[i] = 0
    for (let i = 0; i < n; ++i) count[rank[i]]++
    for (let i = 1; i < m; ++i) count[i] += count[i - 1]
    for (let i = n - 1; i >= 0; --i) sa[--count[rank[idx[i]]]] = idx[i]

    temp[sa[0]] = 1
    for (let i = 1; i < n; ++i) {
      temp[sa[i]] = temp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) < 0 ? 1 : 0)
    }

    for (let i = 0; i < n; ++i) rank[i] = temp[i]
  }

  return sa
}
```

## LCP

`LCP(Longest Common prefix)` 배열은 각 접미사 배열에서 현재 접미사와 이전 접미사의 최장 공통 접두사를 저장하는 배열이다. (정의에 따라서 현재 접미사와 이후 접미사의 최장 공통 접두사로도 생각할 수 있다.)

접미사 s[i..]의 LCP 값이 x라고 했을 때, 이 접미사의 맨 앞 글자를 제거한 접미사 s[i + 1..]의 LCP 값은 최소한 x - 1이 되어야함을 알 수 있다.

예를 들어 2번째 접미사 `issi`pi와 3번째 접미사 `issi`ssipi를 살펴보면 3번째 접미사의 LCP 값은 4이다.

각 접미사에서 맨 앞 한글자를 지우면 `ssi`pi와 `ssi`ssipi가 되고 이는 각각 8번째와 9번째 접미사이며, 9번째 접미사는 최소한 4 - 1개 문자가 8번째 접미사와 같음을 알 수 있다.

따라서 9번째 접미사의 LCP를 구할 때, 앞의 3개 문자는 살펴보지 않아도 되는 것이다.

sa[i] = x의 의미는 접미사들을 사전 순으로 정렬했을 때, i번째 접미사가 s[x..]라는 의미다.

반대로 isa[x] = i의 의미는 접미사 s[x..]는 접미사들을 사전 순으로 정렬했을 때, i번째 접미사라는 의미가 된다.

<CodeSelector names={['index.js']} desc='ex3' />

```js showLineNumbers
function LCP(str) {
  const n = str.length
  const sa = suffixArray(str)
  const isa = new Array(n).fill(0)
  const lcp = new Array(n).fill(0)

  // 접미사 s[sa[i]..]의 등수는 i
  for (let i = 0; i < n; ++i) isa[sa[i]] = i

  for (let i = 0, l = 0; i < n; ++i, l = Math.max(l - 1, 0)) {
    // 0번째 접미사는 패스한다.
    if (isa[i] === 0) continue
    // isa[i]번째 접미사와 isa[i] - 1번째 접미사를 비교한다.
    // i : isa[i]번째 접미사가 시작하는 인덱스
    // j: isa[i] - 1번째 접미사가 시작하는 인덱스 -> sa[isa[i] - 1]
    // 처음 앞 l개는 비교하지 않아도 된다.
    for (let j = sa[isa[i] - 1]; str[i + l] === str[j + l]; ++l);
    lcp[isa[i]] = l
  }

  return lcp
}
```

## 두 번 이상 등장하는 부분문자열 구하기

https://www.acmicpc.net/problem/1605

정리하면 접미사 배열은 문자열 s의 모든 접미사들을 사전 순으로 정렬한 것이고, LCP 배열은 접미사 배열에서 이웃한 접미사들의 접두사들 중 가장 긴 길이를 저장한 배열이다.

접두어의 접두어는 접두어이므로, LCP[i]의 값은 접미사 배열에서 두 인접한 접미사의 공통 접두사의 개수라는 의미도 가지게 된다.

또한 접미사 배열의 이웃한 접미사들의 공통 접두어들은 최소 두 접미사에서 등장하므로, s의 부분문자열들 중에서 두 번 이상 등장한다는 것을 알 수 있다.

예를 들어, 어떤 접미사 s[sa[i]..]의 LCP[i] 값이 3이라면, 두 번 이상 등장하는 부분 문자열 s[sa[i]..1], s[sa[i]..2], s[sa[i]..3]이 존재하고, 그 중에서 가장 길이가 긴 것이 3이라는 의미가 된다.

따라서 LCP 배열의 최댓값은 두 번 이상 등장하는 부분 문자열 중에서 길이가 가장 긴 것이 된다.

## 서로 다른 부분문자열의 개수

https://www.acmicpc.net/problem/11479

문자열 s의 모든 부분문자열의 개수는 문자열 길이 n에서 2 개를 뽑아 시작과 끝을 할당해준 것이다. ($_nH_2$)

이 중에서 서로 다른 부분 문자열의 개수를 구하려면, 두 번 이상 등장하는 부분문자열을 제거해야 한다.

그냥 모든 부분문자열을 구해서 set에 넣으면, $O(n^2)$ 시간이 걸린다.

하지만 모든 부분문자열의 개수에서 LCP 배열의 모든 원소의 합을 빼주면 $O(n\log{n})$ 시간에 구할 수 있다.

## 두 번 이상 등장하는 서로 다른 부분 문자열의 개수

https://www.acmicpc.net/problem/10413

LCP 배열로 구한 두 번 이상 등장하는 부분문자열들은 unique 하지 않다.

예를 들어, s = aabaab라고 해보자.

이때 sa는 [aab, aabaab, ab, abaab, b, baab]이며, lcp 배열은 [0, 3, 1, 2, 0, 1]이다.

이를 통해 최장 공통 접두사들의 접두사들을 살펴보면 [a, aa, aab, a, a, ab, b]가 된다.

unique한 부분문자열을 구하고 싶다면 그냥 set에 넣어서 [a, aa, aab, ab, b]를 구하는 것도 방법이지만, lcp 배열을 살펴보면서 더 빠르게 구할 수 있다.

1. lcp[i] $\le$ lcp[i-1] 이면, sa[i]와 sa[i - 1]의 공통 접두어들은 sa[i - 1]과 sa[i - 2]의 공통 접두어에 포함된다.
2. lcp[i] $\gt$ lcp[i-1] 이면, sa[i]와 sa[i - 1]의 공통 접두어들은 이전에 등장한 적이 없는 접두어가 포함되어 있다.

따라서 인접한 두 lcp 배열이 증가할 때 차를 더해주면 두 번 이상 등장하는 서로 다른 부분 문자열의 개수를 구할 수 있다.

| s[sa[i]..] | lcp의 접두사들   | lcp[i] | 서로 다른 부분 문자열의 개수 |
| ---------- | ---------------- | ------ | ---------------------------- |
| aab        |                  | 0      |                              |
| aabaab     | `a`, `aa`, `aab` | 3      | (3 - 0)개                    |
| ab         | a                | 1      |                              |
| abaab      | a,`ab`           | 2      | (2 - 1)개                    |
| b          |                  | 0      |                              |
| baab       | `b`              | 1      | (1 - 0)개                    |

## References

- https://www.youtube.com/watch?v=qJ_ft3Spcxc&t=236s
