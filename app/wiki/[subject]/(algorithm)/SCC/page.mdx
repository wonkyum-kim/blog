import { CodeSelector } from '@/components/code-selector.tsx'

## 강한 연결 컴포넌트 (Strongly Connected component, SCC)

방향 그래프의 모든 노드에서 다른 모든 노드로 가는 경로가 있는 경우 `강한 연결 그래프`라고 한다.

모든 방향 그래프는 `강한 연결 컴포넌트`로 나눌 수 있다.

강한 연결 컴포넌트는 컴포넌트에 속한 모든 노드가 컴포넌트에 속한 다른 모든 노드로 가는 경로가 있는 최대 노드 집합을 의미한다.

## 코사라주 알고리즘

`코사라주 알고리즘`은 강한 연결 컴포넌트를 찾는 한 방법이다.

1. 방문하지 않은 정점에서 dfs를 실행하고, 처리가 끝난 노드를 순서대로 저장한다.
2. 모든 노드를 방문하지 않은 것으로 바꾸고, 간선의 방향을 바꾼 새로운 인접 리스트를 만든다.
3. 1번에서 저장된 노드를 거꾸로 살펴보면서 dfs를 실행한다. 이때 방문한 노드는 같은 SCC에 속하는 노드가 된다.

<CodeSelector names={['Kosaraju.js']} desc='ex1' />

```js showLineNumbers
const [v, e] = [0, 0].map(() => input.getNumber)
const adj1 = array2d(v, 0)
const adj2 = array2d(v, 0)
const visited = new Array(v).fill(false)
const finished = []

function dfs1(curr) {
  if (visited[curr]) return
  visited[curr] = true
  for (const next of adj1[curr]) dfs1(next)
  finished.push(curr)
}

function dfs2(curr, u) {
  if (visited[curr]) return
  visited[curr] = true
  u.push(curr)
  for (const next of adj2[curr]) dfs2(next, u)
}

function Kosaraju() {
  const scc = []
  for (let i = 0; i < v; ++i) dfs1(i)

  visited.fill(false)
  for (let i = v - 1; i >= 0; --i) {
    const u = []
    dfs2(finished[i], u)
    if (u.length !== 0) scc.push(u)
  }
  return scc
}

function main() {
  for (let i = 0; i < e; ++i) {
    const [a, b] = [0, 0].map(() => input.getNumber)
    adj1[a - 1].push(b - 1) // 정방향
    adj2[b - 1].push(a - 1) // 역방향
  }

  const scc = Kosaraju()
}
```

## 그래프 압축

강한 연결 컴포넌트를 하나의 정점으로 생각하면 더 간단한 형태의 DAG를 만들 수 있다.

컴포넌트를 하나의 노드로 보고 새로운 그래프를 만들 수도 있고 간선만 중요한 경우라면 기존 그래프에서 같은 컴포넌트 내에 있는 간선을 지우는 방법으로도 만들 수 있다.

<CodeSelector names={['SCC.js']} desc='ex2' />

```js
function main() {
  // ...
  const scc = Kosaraju()

  // 각 노드마다 강한 연결 컴포넌트의 번호를 부여한다.
  const sccIndex = new Array(v).fill(0)
  for (let i = 0; i < scc.length; ++i) {
    scc[i].forEach((node) => {
      sccIndex[node] = i
    })
  }

  // 1. 같은 강한 연결 컴포넌트 안에 있는 간선을 모두 제거하는 방법
  const adj3 = array2d(v, 0) // 압축된 그래프의 연결 리스트

  for (let i = 0; i < v; ++i) {
    const curr = i
    const currComponent = sccIndex[curr]
    for (const next of adj1[curr]) {
      const nextComponent = sccIndex[next]
      // 서로 다른 컴포넌트에 연결된 간선들만 추가한다.
      if (currComponent !== nextComponent) {
        adj3[curr].push(next)
      }
    }
  }

  // 2. 강한 연결 컴포넌트를 새로운 노드로 치환하는 방법
  const adj3 = array2d(scc.length, 0) // 압축된 그래프의 연결 리스트

  for (let i = 0; i < v; ++i) {
    const curr = i
    const currComponent = sccIndex[curr]
    for (const next of adj1[curr]) {
      const nextComponent = sccIndex[next]
      // 서로 다른 컴포넌트에 연결된 간선들만 추가한다.
      if (currComponent !== nextComponent) {
        adj3[currComponent].push(nextComponent)
      }
    }
  }
}
```
