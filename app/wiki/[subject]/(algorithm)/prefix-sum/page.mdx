import { CodeSelector } from '@/components/code-selector.tsx'

## 정적인 누적 합

배열의 $i$번째 원소부터 $j$번째 원소까지의 합을 구하기 위해서는 단순히 for 문 한 번을 사용해 구할 수 있다.

하지만 배열의 원소가 변하지 않고, 이런 쿼리가 여러 번 계속될 경우 `누적 합`을 사용해 $O(1)$ 시간에 빠르게 구할 수 있다.

### 1차원 누적 합

1차원 누적 합은 원래 배열 `v`과 이전까지의 모든 원소의 합을 저장하는 배열 `sum`을 관리하면 된다.

a부터 b까지의 모든 원소의 합은 1부터 b까지의 모든 원소의 합에서 1부터 a - 1까지의 모든 원소의 합을 빼면 됩니다. (index는 1부터 시작)

<CodeSelector names={['js']} desc='js1' />

```js
const sum = new Array(n + 1).fill(0)

for (let i = 1; i <= n; ++i) {
  sum[i] = sum[i - 1] + v[i]
}

// a번째 원소부터 b번째 원소까지의 합
console.log(sum[b] - sum[a - 1])
```

### 2차원 누적 합

2차원 누적 합은 1차원 누적 합과 크게 다르지 않다.

전체에서 겹치는 부분을 빼주고 현재 원소를 더해주면 됩니다.

<CodeSelector names={['js']} desc='js2' />

```js
const sum = array2d(n + 1, m + 1, 0)

for (let i = 1; i <= n; ++i) {
  for (let j = 1; j <= m; ++j) {
    sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + v[i][j]
  }
}

// (a1, b1)에서 (a2, b2)까지의 합
console.log(sum[a2][b2] - sum[a2][b1 - 1] - sum[a1 - 1][b2] + sum[a1 - 1][b1 - 1])
```

## 동적인 누적 합 (imos)

주어진 구간에 속한 모든 원소를 업데이트하고 누적 합을 구하기 위해서는 `imos`를 사용한다.

imos는 원소의 갱신 이후에 누적 합을 마지막으로 구해야할 때 사용하면 유용하다.

### 1차원 누적 합

구간 [a, b]에 k를 더한다고 했을 때, `upd[a]`에 k를 더하고, `upd[b + 1]`에 -k를 더한다.

그리고 upd 배열에 누적 합을 구해준다.

<CodeSelector names={['imos']} desc='js3' />

```js
// [0, 0, 0, 0, 0, 0]
const upd = new Array(n + 1).fill(0)

// [0, 4]에 속한 원소를 1만큼 증가시킨다.

// 1. upd[2]과 upd[4 + 1] 변경
// [0, 0, 1, 0, 0, -1]
upd[2] += 1
upd[5] += -1

// 2. upd 누적 합을 구한다.
// [0, 0, 1, 1, 1, 0]
for (let i = 1; i <= n; ++i) {
  upd[i] += upd[i - 1]
}

// 3. 원래 배열 v와 더한다.
for (let i = 1; i <= n; ++i) {
  v[i] += upd[i]
}

// 4. v의 누적 합을 구한다.
```

### 2차원 누적 합

구간 [a, b]에서 [c, d]까지 k만큼 더한다고 했을 때, 다음과 같이 진행한다.

- `udp[a][b] += k`
- `if (c + 1 <= n) udp[c + 1][b] -= k`
- `if (d + 1 <= m) udp[a][d + 1] -= k`
- `if (c + 1 <= n && d + 1 <= m) udp[c + 1][d + 1] += k`

그리고 누적 합을 행과 열 순서로 각각 진행한다.

<CodeSelector names={['js']} desc='js4' />

```js
// 아래로
for (let i = 2; i <= n; ++i) {
  for (let j = 1; j <= m; ++j) {
    udp[i][j] += udp[i - 1][j]
  }
}

// 옆으로
for (let i = 1; i <= n; ++i) {
  for (let j = 2; j <= m; ++j) {
    udp[i][j] += udp[i][j - 1]
  }
}

// 원래 배열에 더함
for (let i = 1; i <= n; ++i) {
  for (let j = 1; j <= m; ++j) {
    v[i][j] += udp[i][j]
  }
}

// 누적합을 구함
for (let i = 1; i <= n; ++i) {
  for (let j = 1; j <= m; ++j) {
    sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + v[i][j]
  }
}
```

## References

- [[Tutorial] 1D and 2D constant time per query range updates (a.k.a difference arrays)](https://codeforces.com/blog/entry/86420)
