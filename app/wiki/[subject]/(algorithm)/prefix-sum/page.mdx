import { CodeSelector } from '@/components/code-selector.tsx'

## 정적인 배열의 누적 합

배열의 $i$번째 원소부터 $j$번째 원소까지의 합을 구하기 위해서는 단순히 for 문 한 번을 사용해 구할 수 있다.

하지만 배열의 원소가 변하지 않고, 이런 쿼리가 여러 번 계속될 경우 `누적 합`을 사용해 $O(1)$ 시간에 빠르게 구할 수 있다.

### 1차원 누적 합

1차원 누적 합은 원래 배열 `v`과 이전까지의 모든 원소의 합을 저장하는 배열 `sum`을 관리하면 된다.

a부터 b까지의 모든 원소의 합은 1부터 b까지의 모든 원소의 합에서 1부터 a - 1까지의 모든 원소의 합을 빼면 된다. (index는 1부터 시작)

<CodeSelector names={['js']} desc='js1' />

```js
const sum = new Array(n + 1).fill(0)

for (let i = 1; i <= n; ++i) {
  sum[i] = sum[i - 1] + v[i]
}

// a번째 원소부터 b번째 원소까지의 합
console.log(sum[b] - sum[a - 1])
```

### 2차원 누적 합

2차원 누적 합은 1차원 누적 합과 크게 다르지 않다.

전체에서 겹치는 부분을 빼주고 현재 원소를 더해주면 된다.

<CodeSelector names={['js']} desc='js2' />

```js
const sum = array2d(n + 1, m + 1, 0)

for (let i = 1; i <= n; ++i) {
  for (let j = 1; j <= m; ++j) {
    sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + v[i][j]
  }
}

// (a1, b1)에서 (a2, b2)까지의 합
console.log(sum[a2][b2] - sum[a2][b1 - 1] - sum[a1 - 1][b2] + sum[a1 - 1][b1 - 1])
```

## 동적인 배열의 누적 합 (imos)

주어진 구간에 속한 모든 원소를 업데이트하고 누적 합을 구하기 위해서는 `imos`를 사용한다.

imos는 원소의 갱신이 끝난 후에 누적 합을 마지막으로 구해야할 때 사용하면 유용하다.

### 1차원 누적 합

구간 [a, b]에 k를 더한다고 했을 때, `upd[a]`에 k를 더하고, `upd[b + 1]`에 -k를 더한다.

그리고 upd 배열에 누적 합을 구해준다.

<CodeSelector names={['imos']} desc='js3' />

```js
const v = new Array(n + 1).fill(0) // v: 원래 배열
const upd = new Array(n + 1).fill(0) // upd: 업데이트 배열

// 1. v를 입력 받는다. (1 index)

// 2. 쿼리를 처리한다.
upd[a] += k
if (b + 1 <= n) upd[b + 1] += -k

// 3. upd 배열의 누적 합을 구한다.
for (let i = 1; i <= n; ++i) upd[i] += upd[i - 1]

// 4. 원래 배열 v와 더한다.
for (let i = 1; i <= n; ++i) v[i] += upd[i]

// 5. v의 누적 합을 구한다.
```

### 2차원 누적 합

구간 [a, b]에서 [c, d]까지 k만큼 더한다고 했을 때, 다음과 같이 진행한다.

- `upd[a][b] += k`
- `if (c + 1 <= n) upd[c + 1][b] -= k`
- `if (d + 1 <= m) upd[a][d + 1] -= k`
- `if (c + 1 <= n && d + 1 <= m) upd[c + 1][d + 1] += k`

그리고 누적 합을 행과 열 순서로 각각 진행한다.

<CodeSelector names={['js']} desc='js4' />

```js
// 1. v를 입력 받는다. (1 index)

// 2. 쿼리를 처리한다.
upd[a][b] += k
if (c + 1 <= n) upd[c + 1][b] -= k
if (d + 1 <= m) upd[a][d + 1] -= k
if (c + 1 <= n && d + 1 <= m) upd[c + 1][d + 1] += k

// 3. upd 배열의 누적 합을 구한다.

// 아래로
for (let i = 2; i <= n; ++i) {
  for (let j = 1; j <= m; ++j) {
    upd[i][j] += upd[i - 1][j]
  }
}

// 옆으로
for (let i = 1; i <= n; ++i) {
  for (let j = 2; j <= m; ++j) {
    upd[i][j] += upd[i][j - 1]
  }
}

// 4. 원래 배열 v와 더한다.
for (let i = 1; i <= n; ++i) {
  for (let j = 1; j <= m; ++j) {
    v[i][j] += upd[i][j]
  }
}

// 5. 2차원 누적 합 배열을 구한다.
for (let i = 1; i <= n; ++i) {
  for (let j = 1; j <= m; ++j) {
    sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + v[i][j]
  }
}
```

## 문제

### [11659번: 구간 합 구하기 4](https://www.acmicpc.net/problem/11659)

정적인 1차원 배열의 누적 합을 구하는 문제

### [11660번: 구간 합 구하기 5](https://www.acmicpc.net/problem/11660)

정적인 2차원 배열의 누적 합을 구하는 문제

### [25826번: 2차원 배열 다중 업데이트 단일 합](http://localhost:3000/wiki/Algorithm/Prefix-sum)

동적인 2차원 배열의 누적 합을 구하는 문제

## References

- [[Tutorial] 1D and 2D constant time per query range updates (a.k.a difference arrays)](https://codeforces.com/blog/entry/86420)
