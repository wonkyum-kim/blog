import { CodeSelector } from '@/components/code-selector.tsx'

## 검색 엔진

서로 같은 [강한 연결 컴포넌트](/wiki/Algorithm/SCC)에 있는 노드들 끼리는 점수를 매기지 않기 때문에 압축 그래프를 만든다.

압축된 그래프를 구하는 쉬운 방법은 같은 연결 요소에 속한 노드들 끼리 연결된 간선을 지우는 것이다.

압축된 그래프에 대하여 위상 정렬을 하고 다이나믹 프로그래밍을 통해 점수를 구할 수 있다.

<CodeSelector names={['1108.js']} desc='ex1' />

```js showLineNumbers
let v = 0
let adj1 = []
let adj2 = []
let visited = []
let finished = []
const obj = {}

function dfs1(curr) {
  if (visited[curr]) return
  visited[curr] = true
  for (const next of adj1[curr]) {
    dfs1(next)
  }
  finished.push(curr)
}

function dfs2(curr, u) {
  if (visited[curr]) return
  visited[curr] = true
  u.push(curr)
  for (const next of adj2[curr]) {
    dfs2(next, u)
  }
}

function Kosaraju() {
  finished = []
  visited = new Array(v).fill(false)
  for (let i = 0; i < v; ++i) {
    dfs1(i)
  }

  const scc = []
  visited = new Array(v).fill(false)
  for (let i = v - 1; i >= 0; --i) {
    const u = []
    dfs2(finished[i], u)
    if (u.length !== 0) scc.push(u)
  }
  return scc
}

function topologicalSort(indegree, adj) {
  const q = new Queue()
  const cost = new BigInt64Array(v).fill(1n)

  for (let i = 0; i < v; ++i) {
    if (indegree[i] === 0) {
      q.push(i)
    }
  }

  for (let i = 0; i < v; ++i) {
    if (q.empty()) break
    const curr = q.front()
    q.pop()

    for (const next of adj[curr]) {
      cost[next] += cost[curr]
      indegree[next]--
      if (indegree[next] === 0) {
        q.push(next)
      }
    }
  }

  return cost
}

function getNode(x) {
  if (obj[x] === undefined) {
    obj[x] = v++
  }
  return obj[x]
}

// 같은 scc끼리는 점수를 안매김
// 다른 scc로 연결되는 간선만 중요함.
function solve() {
  const n = input.getNumber
  adj1 = array2d(1200, 0)
  adj2 = array2d(1200, 0)

  for (let i = 0; i < n; ++i) {
    const b = input.get
    const bNum = getNode(b)
    const start = new Array(input.getNumber).fill('').map(() => input.get)
    for (const a of start) {
      const aNum = getNode(a)
      adj1[aNum].push(bNum)
      adj2[bNum].push(aNum)
    }
  }

  const target = input.get
  const targetNum = getNode(target)

  adj1 = adj1.slice(0, v)
  adj2 = adj2.slice(0, v)

  const scc = Kosaraju()

  const sccIndex = new Array(v).fill(0)
  for (let i = 0; i < scc.length; ++i) {
    scc[i].forEach((item) => {
      sccIndex[item] = i
    })
  }

  // 같은 컴포넌트 안에 있는 간선을 모두 제거한다.
  const indegree = new Array(v).fill(0)
  const adj3 = array2d(v, 0)

  for (let i = 0; i < v; ++i) {
    const curr = i
    const currComponent = sccIndex[curr]
    for (const next of adj1[curr]) {
      const nextComponent = sccIndex[next]
      if (currComponent !== nextComponent) {
        adj3[curr].push(next)
        indegree[next]++
      }
    }
  }

  const cost = topologicalSort(indegree, adj3)
  console.log(cost[targetNum].toString())
}

solve()
```
