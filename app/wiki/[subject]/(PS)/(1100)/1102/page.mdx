import { CodeSelector } from '@/components/code-selector.tsx'

## 발전소

비트필드를 이용한 다이나믹 프로그래밍은 다음과 같이 진행된다.

1. `dp[state]`가 -1이 아니면 그대로 반환
2. `dp[state]`가 -1이면 초기 값으로 설정
3. top-down으로 `dp[state]`를 갱신한다.

<CodeSelector names={['1102.js']} desc='ex1' />

```js showLineNumbers {18, 20, 28}
let n = 0
let p = 0
let v = [[]]
let dist = []

function popCount(n) {
  let [count, nCopy] = [0, n]
  while (nCopy) {
    nCopy &= nCopy - 1
    count += 1
  }

  return count
}

function dfs(state) {
  if (popCount(state) >= p) return 0
  if (dist[state] !== -1) return dist[state]

  dist[state] = Infinity
  for (let i = 0; i < n; ++i) {
    // 현재 켜져 있는 발전소 중에서
    if ((state & (1 << i)) === 0) continue
    for (let j = 0; j < n; ++j) {
      // 현재 꺼져 있는 발전소를 고른다
      if ((state & (1 << j)) === 1) continue
      const nextState = state | (1 << j)
      dist[state] = Math.min(dist[state], v[i][j] + dfs(nextState))
    }
  }
  return dist[state]
}

function solve() {
  n = input.getNumber
  v = array2d(n, n, 0)
  for (let i = 0; i < n; ++i) {
    for (let j = 0; j < n; ++j) {
      v[i][j] = input.getNumber
    }
  }
  const s = input.get
  p = input.getNumber
  dist = new Array((1 << n) + 1).fill(-1)

  let state = 0
  for (let i = 0; i < n; ++i) {
    if (s[i] === 'Y') state |= 1 << i
  }

  const ans = dfs(state)
  console.log(ans === Infinity ? -1 : ans)
}

solve()
```
