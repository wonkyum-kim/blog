import { CodeSelector } from '@/components/code-selector.tsx'

## invariant 함수의 타입 추론

`Zustand`의 `create` 함수를 사용할 때는 아래와 같이 직접 타입(`BearState`)을 명시해야한다.

<CodeSelector names={['ts']} desc='ex1' />

```ts {8} showLineNumbers
import { create } from 'zustand'

interface BearState {
  bears: number
  increase: (by: number) => void
}

const useBearStore = create<BearState>()((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
}))
```

왜 추론을 사용하지 않고 타입을 직접 전달해야 하는가?

그 이유는 `create` 함수의 구현체가 무공변성(invariant)을 띄기 때문이다.

<CodeSelector names={['ts']} desc='ex2' />

```ts showLineNumbers
declare const create: <T>(f: (get: () => T) => T) => T

const x = create((get) => ({
  foo: 0,
  bar: () => get(),
}))
// `x` is inferred as `unknown` instead of
// interface X {
//   foo: number,
//   bar: () => X
// }
```

타입스크립트 컴파일러는 T를 추론하고 싶지만, `(get: () => T) => T`가 무공변적이기 때문에 어디서 T가 오는지 알 수 없다.

그래서 타입스크립트는 T를 unknown으로 처리해버리기 때문에 직접 타입을 전달 해줘야 한다.

## 왜 커링을 사용해야 하는가?

맨 처음 코드를 다시 살펴보면 `create<BearState>()(...)`와 같이 커링을 사용하고 있는 것을 볼 수 있다.

그 이유는 타입스크립트에서 제네릭을 사용할 때, 모든 제네릭을 다 전달하거나 아니면 컴파일러가 다 추론하도록 하는 것만 가능하기 때문이다.

즉, 일부는 직접 타입(`BearState`)을 전달하고 일부는 컴파일러가 추론하도록 하는 것이 불가능하기 때문에 이렇게 사용하고 있는 것이다.

아래 예제를 살펴보자.

<CodeSelector names={['ts']} desc='ex3' />

```ts {1-3} showLineNumbers
declare const withError: <T, E>(
  p: Promise<T>
) => Promise<[error: undefined, value: T] | [error: E, value: undefined]>

declare const doSomething: () => Promise<string>

const main = async () => {
  let [error, value] = await withError(doSomething())
}
```

여기서 `E`는 지금 `unknown`으로 추론되고 있다.

개발자가 직접 `E`가 `Foo` 타입이 되도록 따로 전달하고 싶어도, 아까 말했듯이 이는 불가능하다.

왜냐하면 `T`가 컴파일러에 의해 `string`으로 추론되고 있는 중이기 때문이다.

이것을 가능하기 위해서 런타임에 아무것도 하지 않는 커링 버전을 사용한다. 즉, 일종의 핵이다.

<CodeSelector names={['ts']} desc='ex4' />

```ts {1-3} showLineNumbers
declare const withError: {
  <E>(): <T>(p: Promise<T>) => Promise<[error: undefined, value: T] | [error: E, value: undefined]>
}

declare const doSomething: () => Promise<string>

interface Foo {
  bar: string
}

const main = async () => {
  let [error, value] = await withError<Foo>()(doSomething())
}
```

## References

- https://docs.pmnd.rs/zustand/guides/typescript
