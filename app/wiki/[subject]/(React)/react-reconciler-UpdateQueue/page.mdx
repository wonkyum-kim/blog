import { CodeSelector } from '@/components/code-selector.tsx'

## UpdateQueue

`UpdateQueue`는 우선순위가 지정된 업데이트의 연결 리스트다.

파이버와 마찬가지로, UpdateQueue는 더블 버퍼링을 사용하므로 쌍으로 제공된다.

`current 큐`는 화면의 가시적인 상태를 나타내고, `work-in-progress 큐`는 커밋되기 전에 비동기적으로 변형 및 처리될 수 있다.

- 만약에 `work-in-progress 렌더링`이 완료되기 전에 삭제되면, current 큐를 복제하여 새로운 work-in-progress를 만든다.
- 업데이트를 스케줄 하려면, 두 큐에 모두 업데이트를 추가해야한다.
- 각 큐는 처리되지 않은 첫 번째 업데이트에 대한 포인터를 유지한다.
- work-in-progress 큐의 포인터는 항상 current 큐의 포인터보다 같거나 더 큰 위치를 가지게 된다.
- current 큐의 포인터는 work-in-progress를 스왑할 때 커밋 단계에서만 업데이트 된다.

<CodeSelector names={['pointer']} desc='ex1' />

```text
Current pointer:           A - B - C - D - E - F
Work-in-progress pointer:              D - E - F
                                       ^
                work-in-progress 큐는 current 큐 보다 업데이트를 더 많이 처리하였다.
```

두 큐에 모두 업데이트를 추가하는 이유는 업데이트를 처리하지 않고 삭제할 수 있기 때문이다.

예를 들어 work-in-progress 큐에만 업데이트를 추가하는 경우, current에서 복제하여 work-in-progress의 렌더링이 다시 시작될 때마다 일부 업데이트가 손실될 수 있다.

마찬가지로, current 큐에만 업데이트를 추가하면, work-in-progress 큐가 커밋되어 current 큐와 스왑될 때마다 업데이트가 손실된다.

그러나 두 큐에 모두 추가하면, 업데이트가 다음 work-in-progress의 일부가 될 것이 보장된다.

그리고 work-in-progress 큐는 커밋하면 current 큐가 되므로, 동일한 업데이트를 두 번 적용할 위험이 없다.

---

업데이트는 우선순위에 따라 정렬되지 않고 삽입된다. 따라서 새 업데이트는 항상 리스트의 끝에 추가된다.

하지만 우선순위는 여전히 중요하다. 렌더링 단계에서 업데이트 큐를 처리할 때, 우선순위가 충분한 업데이트만 결과에 포함된다.

우선순위가 충분하지 않아 업데이트를 건너뛰면, 나중에 우선순위가 낮은 렌더링 중에 처리되도록 큐에 남는다.

중요한 점은, 건너뛴 업데이트 이후의 모든 업데이트도 우선순위에 관계 없이 큐에 남아있다는 것이다.

즉, 우선순위가 높은 업데이트는 때때로 두 개의 별도 우선순위로 두 번 처리된다.

또한 큐의 첫 번째 업데이트가 적용되기 전 상태를 나타내는 `기본 상태(base state)`를 추적한다.

예를 들어 기본 상태 ' '와 우선순위를 나타내는 숫자가 있고, 이전 상태에 문자를 추가하여 업데이트를 적용하는 큐가 주어지면, React는 이러한 업데이트를 두 개의 별도 렌더링으로 처리한다.

<CodeSelector names={['queue']} desc='ex2' />

```text
A1 - B2 - C1 - D2

First render, at priority 1:
Base state: ''
Updates: [A1, C1]
Result state: 'AC'

Second render, at priority 2:
Base state: 'A'            <-  The base state does not include C1, because B2 was skipped.
Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2
Result state: 'ABCD'
```

삽입 순서대로 업데이트를 처리하고, 이전 업데이트를 건너뛸 때 높은 우선순위 업데이트를 리베이스하기 때문에, 최종 결과는 우선순위에 관계 없이 결정적이다.

즉, 중간 상태는 시스템 자원에 따라서 다를 수 있지만 최종 상태는 항상 동일하다.

## initializeUpdateQueue

Fiber 객체에 `updateQueue`를 추가하는 역할을 한다.

어디에서 쓰이나? -> createRoot를 호출하면 Fiber 객체를 생성하는데, 여기에 updateQueue를 추가할 때 쓰인다.

updateQueue는 아래와 같이 생겼다.

TODO: 자세히 살펴보기

<CodeSelector names={['UpdateQueue']} desc='ex3' />

```ts showLineNumbers
const queue: UpdateQueue<State> = {
  baseState: fiber.memoizedState,
  firstBaseUpdate: null,
  lastBaseUpdate: null,
  shared: {
    pending: null,
    lanes: NoLanes,
    hiddenCallbacks: null,
  },
  callbacks: null,
}
```

## cloneUpdateQueue

current 업데이트 큐를 work-in-progress 업데이트 큐에 복사한다.

## createUpdate

`Update` 객체를 생성한다.

Update 객체는 아래와 같이 생겼다.

<CodeSelector names={['Update']} desc='ex4' />

```ts showLineNumbers
const update: Update<mixed> = {
  lane,
  tag: UpdateState,
  payload: null,
  callback: null,
  next: null,
}
return update
```

## enqueueUpdate

{/* UpdateQueue에 업데이트를 추가한다. */}

{/* 앞서 current 큐와 work-in-progress 큐 모두 업데이트를 추가해야한다고 설명하였는데, 실제 구현에서는 sharedQueue에 추가하는 방식으로 구현되어 있는 것으로 보인다. */}

isUnsafeClassRenderPhaseUpdate는 클래스 컴포넌트에 해당하는 내용이므로 다루지 않는다.

<CodeSelector names={['enqueueUpdate']} desc='ex5' />

```ts showLineNumbers {14}
export function enqueueUpdate<State>(
  fiber: Fiber,
  update: Update<State>,
  lane: Lane,
): FiberRoot | null {

  const updateQueue = fiber.updateQueue;
  /* ... */
  const sharedQueue: SharedQueue<State> = (updateQueue: any).shared;

  if (isUnsafeClassRenderPhaseUpdate(fiber)) {
    /* ... */
  } else {
    return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
  }
}
```

enqueueConcurrentClassUpdate가 호출하는 enqueueUpdate는 위와 이름이 같지만 다른 함수이다.

<CodeSelector
  names={['enqueueConcurrentClassUpdate', 'enqueueUpdate', 'getRootForUpdatedFiber']}
  desc='ex6'
/>

```ts showLineNumbers {9-10}
export function enqueueConcurrentClassUpdate<State>(
  fiber: Fiber,
  queue: ClassQueue<State>,
  update: ClassUpdate<State>,
  lane: Lane,
): FiberRoot | null {
  const concurrentQueue: ConcurrentQueue = (queue: any);
  const concurrentUpdate: ConcurrentUpdate = (update: any);
  enqueueUpdate(fiber, concurrentQueue, concurrentUpdate, lane);
  return getRootForUpdatedFiber(fiber);
}
```

```ts showLineNumbers {18-21, 23-24, 30-35}
// If a render is in progress, and we receive an update from a concurrent event,
// we wait until the current render is over (either finished or interrupted)
// before adding it to the fiber/hook queue. Push to this array so we can
// access the queue, fiber, update, et al later.
const concurrentQueues: Array<any> = []
let concurrentQueuesIndex = 0

let concurrentlyUpdatedLanes: Lanes = NoLanes

function enqueueUpdate(
  fiber: Fiber,
  queue: ConcurrentQueue | null,
  update: ConcurrentUpdate | null,
  lane: Lane
) {
  // Don't update the `childLanes` on the return path yet. If we already in
  // the middle of rendering, wait until after it has completed.
  concurrentQueues[concurrentQueuesIndex++] = fiber
  concurrentQueues[concurrentQueuesIndex++] = queue
  concurrentQueues[concurrentQueuesIndex++] = update
  concurrentQueues[concurrentQueuesIndex++] = lane

  // 비트 연산을 하는 함수로 concurrentlyUpdatedLanes과 lane을 합친다.
  concurrentlyUpdatedLanes = mergeLanes(concurrentlyUpdatedLanes, lane)

  // The fiber's `lane` field is used in some places to check if any work is
  // scheduled, to perform an eager bailout, so we need to update it immediately.
  // TODO: We should probably move this to the "shared" queue instead.

  // fiber와 반대편 fiber의 lane과도 합친다.
  fiber.lanes = mergeLanes(fiber.lanes, lane)
  const alternate = fiber.alternate
  if (alternate !== null) {
    alternate.lanes = mergeLanes(alternate.lanes, lane)
  }
}
```

```ts showLineNumbers {5-10, 12-13}
function getRootForUpdatedFiber(sourceFiber: Fiber): FiberRoot | null {
  /* ... */
  let node = sourceFiber;
  let parent = node.return;
  // 최상위 Fiber 객체를 찾아 올라간다.
  while (parent !== null) {
    detectUpdateOnUnmountedFiber(sourceFiber, node);
    node = parent;
    parent = node.return;
  }

  // stateNode는 FiberRootNode가 된다.
  return node.tag === HostRoot ? (node.stateNode: FiberRoot) : null;
}
```
