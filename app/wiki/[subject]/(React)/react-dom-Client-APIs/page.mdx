import { CodeSelector } from '@/components/code-selector.tsx'

## createRoot

`createRoot`는 `ReactDOMRoot`를 생성하는 함수다.

<CodeSelector names={['index.js']} desc='ex1' />

```jsx
import { createRoot } from 'react-dom/client'

// root: ReactDOMRoot
const root = createRoot(document.getElementById('root'))
```

1단계: FiberRootNode를 생성한다.

9번째 라인의 `root`는 `FiberRootNode`이다.

FiberRootNode 객체와 Fiber 객체는 서로를 가리키고 있다.

<CodeSelector names={['createRoot']} desc='ex2' />

```ts {6-13} showLineNumbers
export function createRoot(
  container: Element | Document | DocumentFragment,
  options?: CreateRootOptions
): RootType {
  /* ... */
  // 1단계: FiberRootNode를 생성한다.
  // root.current -> uninitializedFiber
  // uninitializedFiber.stateNode -> root
  const root = createContainer(
    container,
    ConcurrentRoot
    /* ... */
  )
  /* ... */
}
```

2단계: container에 Fiber 객체 연결하기

`container`는 createRoot에 넘겨준 document.getElementById('root')이다.

markContainerAsRoot에서는 이 container가 root.current 즉, Fiber 객체를 가리키도록 한다.

<CodeSelector names={['createRoot']} desc='ex3' />

```ts showLineNumbers {10-12}
export function createRoot(
  container: Element | Document | DocumentFragment,
  options?: CreateRootOptions
): RootType {
  /* ... */
  // 1단계: FiberRootNode를 생성한다.
  // root.current -> uninitializedFiber
  // uninitializedFiber.stateNode -> root

  // 2단계: container에 Fiber 객체 연결하기
  // container[internalContainerInstanceKey] -> root.current
  markContainerAsRoot(root.current, container)
  /* ... */
}
```

3단계: 이벤트 설정

`rootContainerElement`는 위에서 살펴본 root와 같고 이름만 바뀌었다.

각 이벤트마다 설정하는 것이 다르고 복잡하므로 자세히 살펴보지 않고 넘어간다.

<CodeSelector names={['createRoot']} desc='ex4' />

```ts showLineNumbers {13-15}
export function createRoot(
  container: Element | Document | DocumentFragment,
  options?: CreateRootOptions
): RootType {
  /* ... */
  // 1단계: FiberRootNode를 생성한다.
  // root.current -> uninitializedFiber
  // uninitializedFiber.stateNode -> root

  // 2단계: container에 Fiber 객체 연결하기
  // container[internalContainerInstanceKey] -> root.current

  // 3단계: 이벤트 설정
  // React와 DOM의 이벤트를 연결
  listenToAllSupportedEvents(rootContainerElement)

  /* ... */
}
```

4단계: ReactDOMRoot 반환

createRoot는 마지막으로 `ReactDOMRoot`을 반환한다.

ReactDOMRoot.\_internalRoot는 FiberRootNode인 root를 가리킨다.

이후 ReactDOMRoot에는 render와 unmount 메서드가 추가된다.

<CodeSelector names={['createRoot']} desc='ex5' />

```ts showLineNumbers {16-18}
export function createRoot(
  container: Element | Document | DocumentFragment,
  options?: CreateRootOptions
): RootType {
  /* ... */
  // 1단계: FiberRootNode를 생성한다.
  // root.current -> uninitializedFiber
  // uninitializedFiber.stateNode -> root

  // 2단계: container에 Fiber 객체 연결하기
  // container[internalContainerInstanceKey] -> root.current

  // 3단계: 이벤트 설정
  // React와 DOM의 이벤트를 연결

  // 4단계: ReactDOMRoot 반환
  // ReactDOMRoot._internalRoot -> root
  return new ReactDOMRoot(root)
}
```

## ReactDOMRoot.render

createRoot가 반환한 ReactDOMRoot 객체의 render 메서드에 대해서 살펴본다.

<CodeSelector names={['index.js']} desc='ex6' />

```js showLineNumbers {5}
import { createRoot } from 'react-dom/client'
import { App } from './App.js'

const root = createRoot(document.getElementById('root'))
root.render(<App />)
```

1단계: updateContainer를 호출한다.

render 메서드는 ReactDOMRoot와 ReactDOMHydrationRoot가 공유한다.

<CodeSelector names={['render']} desc='ex7' />

```js showLineNumbers {6-8}
ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
  // $FlowFixMe[missing-this-annot]
  function (children: ReactNodeList): void {
    /* ... */

    // 1단계: updateContainer를 호출한다.
    // root는 FiberRootNode로 this._internalRoot로 얻을 수 있다.
    updateContainer(children, root, null, null);
  };
```

2단계: requestUpdateLane을 호출한다.

첫 호출 시에는 transition은 null이 될 것이다.

<CodeSelector
  names={['updateContainer', 'requestUpdateLane', 'requestCurrentTransition']}
  desc='ex8'
/>

```js showLineNumbers {10-11}
export function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,
  callback: ?Function,
): Lane {
  // Fiber 객체 (uninitializedFiber)
  const current = container.current;

  // 2단계: requestUpdateLane을 호출한다.
  const lane = requestUpdateLane(current);

  updateContainerImpl(
    current,
    lane,
    element,
    container,
    parentComponent,
    callback,
  );
  return lane;
}
```

```js showLineNumbers {6-11, 13}
export function requestUpdateLane(fiber: Fiber): Lane {
  // Special cases
  const mode = fiber.mode;
  /* ...*/

  // 2-1단계: ReactSharedInternals.T를 얻는다.
  // 첫 호출 시에는 ReactSharedInternals.T가 null일 것이다.
  const transition = requestCurrentTransition();
  if (transition !== null) {
    /* ... */
  }
}
```

```js showLineNumbers {2}
export function requestCurrentTransition(): BatchConfigTransition | null {
  return ReactSharedInternals.T;
}
```

resolveUpdatePriority에서는 어떤 이벤트에 해당하는 우선순위를 나타내는 정수를 반환할 것인데, 일단은 DefaultEventPriority라고 생각된다.

결국 lane은 우선순위를 나타내는 어떤 정수 값이라는 것을 확인할 수 있다.

<CodeSelector
  names={['requestUpdateLane', 'resolveUpdatePriority', 'eventPriorityToLane']}
  desc='ex9'
/>

```js showLineNumbers {7-8}
export function requestUpdateLane(fiber: Fiber): Lane {
  // Special cases
  const mode = fiber.mode;
  /* ...*/

  // 2-1단계: ReactSharedInternals.T를 얻는다.
  // 2-2단계: resolveUpdatePriority와 eventPriorityToLane를 호출한다.
  return eventPriorityToLane(resolveUpdatePriority());
}
```

```js showLineNumbers {2, 10-17}
export function resolveUpdatePriority(): EventPriority {
  const updatePriority = ReactDOMSharedInternals.p; /* currentUpdatePriority */
  // 첫 실행시에는 NoEventPriority일 것이다.
  if (updatePriority !== NoEventPriority) {
    return updatePriority;
  }

  // 아래 부분 코드의 동작은 정확히 모르겠다.

  // CSR이므로 window.event는 undefined가 아닐 것 같다.
  const currentEvent = window.event;
  if (currentEvent === undefined) {
    return DefaultEventPriority;
  }
  // 시작할 때 어떤 이벤트가 발생할 것인데,
  // 아마도 DefaultEventPriority를 반환할 것 같다.
  return getEventPriority(currentEvent.type);
}
```

```js showLineNumbers {2-3}
export function eventPriorityToLane(updatePriority: EventPriority): Lane {
  // 아무것도 하지 않고 그대로 반환한다.
  return updatePriority;
}
```

3단계: updateContainerImpl을 호출한다.

TODO

<CodeSelector names={['updateContainer', 'updateContainerImpl']} desc='ex10' />

```js showLineNumbers {13-21}
export function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,
  callback: ?Function,
): Lane {
  // Fiber 객체 (uninitializedFiber)
  const current = container.current;

  // 2단계: requestUpdateLane을 호출한다.
  const lane = requestUpdateLane(current);

  // 3단계: updateContainerImpl을 호출한다.
  updateContainerImpl(
    current,
    lane,
    element,
    container,
    parentComponent,
    callback,
  );
  return lane;
}
```

```js showLineNumbers {20-22, 32-34}
function updateContainerImpl(
  rootFiber: Fiber,
  lane: Lane,
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,
  callback: ?Function,
): void {

  /* ... */

  // 첫 호출시 context는 null이다.
  const context = getContextForSubtree(parentComponent);
  if (container.context === null) {
    container.context = context;
  } else {
    container.pendingContext = context;
  }

  // react-reconciler-UpdateQueue를 참고
  // Update 객체를 반환한다.
  const update = createUpdate(lane);
  // Caution: React DevTools currently depends on this property
  // being called "element".
  update.payload = {element};

  callback = callback === undefined ? null : callback;
  if (callback !== null) {
    update.callback = callback;
  }

  // react-reconciler-UpdateQueue를 참고
  // FiberRootNode를 반환한다.
  const root = enqueueUpdate(rootFiber, update, lane);
  if (root !== null) {
    scheduleUpdateOnFiber(root, rootFiber, lane);
    entangleTransitions(root, rootFiber, lane);
  }
}
```

### ReactDOMRoot.unmount

TODO

### hydrateRoot

TODO
