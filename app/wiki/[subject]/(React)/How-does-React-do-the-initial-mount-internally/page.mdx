import { CodeSelector } from '@/components/code-selector.tsx'

## How does React do the initial mount internally?

> https://jser.dev/2023-07-14-initial-mount/ 를 읽고 정리해본 글.

아래 코드가 첫 렌더링 (initial mount)에서 어떻게 동작하는지에 대해 살펴본다.

<CodeSelector names={['App.jsx']} desc='ex1' />

```jsx showLineNumbers
import { useState } from 'react'

function Link() {
  return <a href='https://jser.dev'>jser.dev</a>
}

export default function App() {
  const [count, setCount] = useState(0)

  const handleClick = () => {
    setCount((prev) => prev + 1)
  }

  return (
    <div>
      <p>
        <Link />
        <br />
        <button onClick={handleClick}>click me - {count}</button>
      </p>
    </div>
  )
}
```

## 1. Brief introduction on Fiber Architecture

FiberNode로 이루어진 Fiber 트리는 FiberRootNode의 `current 포인터`가 가리킨다.

Fiber 트리는 `current`와 `workInProgress` 두 개가 존재한다.

current Fiber 트리는 실제로 화면에 보여지는 모습이고, workInProgress 트리는 작업 중인 모습이다.

current 포인터를 변경하면서 두 트리를 이동할 수 있고 화면을 업데이트 한다.

FiberNode 중 일부는 실제 DOM과 대응된다. (e.g. HostComponent)

### 1.1 FiberRootNode

FiberRootNode는 React 루트와 같은 역할을 하는 특별한 노드다.

FiberRootNode.current는 실제 Fiber 트리를 가리킨다.

새로운 Fiber 트리가 생성되면, current 포인터를 생성된 새로운 트리를 가리키도록 변경한다.

정확하게는 새로 생성된 Fiber 트리의 루트 FiberNode인 `HostRoot`를 가리킨다.

### 1.2 FiberNode

FiberNode는 Fiber 트리를 이루고 있는 구성 요소이다.

아래와 같은 프로퍼티들을 가지고 있다.

- `tag`: FiberNode의 종류를 나타낸다.
- `stateNode`: 백업 데이터. HostCompoenent의 경우 실제 DOM에 해당한다.
- `elementType`: 컴포넌트 함수 또는 HTML 태그
- `flags`: 커밋 단계에서 업데이트를 적용해야 하는 지를 나타낸다. subtreeFlags는 서브트리에 적용된다.
- `lanes`: 보류된 업데이트의 우선순위를 나타낸다. childLanes는 서브트리에 적용된다.
- `child, sibling, return`: 트리 구조를 만들기 위한 포인터
- `memoizedState`: 중요한 데이터. FunctionComponent의 경우 hook을 의미한다.

위에서 잠깐 언급 하였듯이 FiberNode의 종류는 tag를 통해 확인 가능하며 아래와 같은 것들이 있다.

- `HostRoot`: Fiber 트리의 루트
- `FunctionComponent`: 함수형 컴포넌트
- `HostCompoenent`: 실제 DOM 노드

## 2. Initial mount in Trigger phase

`createRoot()`는 비어있는 HostRoot를 가지고 있는 `current Fiber 트리`를 생성한다.

`root.render(<App />)`은 HostRoot의 업데이트를 스케줄한다.

`<App />`은 update 객체의 payload에 저장된다.

<CodeSelector names={['index.js']} desc='ex1' />

```js showLineNumbers
import { createRoot } from 'react-dom/client'
import { App } from './App'

const root = createRoot(document.getElementById('root'))
root.render(<App />)
```

## 3. Initial mount in Render Phase

### 3.1 performConcurrentWorkOnRoot()

`performConcurrentWorkOnRoot()`는 initial mount와 re-render에서 렌더링을 시작하는 진입 점이다.

이름과 달리, 필요하면 sync로 진행된다.

sync로 렌더링을 진행해야 하는 경우는 `lane`을 보고 판단할 수 있다.

Initial mount의 경우 DefaultLane에 해당하는데, blocking lane이라서 sync로 진행한다.

(blocking lane은 렌더링이 인터럽트 되지 않아야 한다는 것을 의미한다.)

### 3.2 renderRootSync()

`renderRootSync()`는 while 루프이다.

workLoopSync()에서 `전역 변수 workInProgress`가 null이 될 때까지 performUnitOfWork()를 실행한다.

workInProgress 트리의 노드는 탑 다운 방식으로 생성되며, 각 노드가 생성될 때마다 전역 변수 workInProgress에 저장된다. (3.3 performUnitOfWork() 참고)

따라서 전역 변수 workInProgress가 null이 된다는 의미는 workInProgress 트리를 완성해서 더 이상 렌더링 할 것이 없다는 의미가 된다.

### 3.3 performUnitOfWork()

`performUnitOfWork()`는 React가 단일 FiberNode에서 수행할 작업이 있는지 확인하는 곳이다.

`beginWork()`를 호출하여 전역 변수 workInProgress에 저장된 FiberNode의 실제 렌더링을 발생시킨다.

이때 workInProgress의 tag에 따라서 다른 렌더링을 진행하게 된다.

예를 들어, tag가 HostRoot이면 updateHostRoot()를 호출하고, FunctionComponent이면 updateFunctionComponent()를 호출한다.

beginWork()에서 반환된 것은 다음에 업데이트를 진행할 FiberNode가 되며, performUnitOfWork에서 전역 변수 workInProgress에 저장된다.

### 3.4 prepareFreshStack()

renderRootSync()에서 performUnitOfWork()를 실행하기 이전에 `prepareFreshStack()`을 호출한다.

매번 새로운 렌더링이 시작할 때마다, current Fiber 트리의 HostRoot로부터 복사된 새로운 workInProgress Fiber 트리를 생성한다.

복사된 workInProgress의 HostRoot를 전역 변수 workInProgress에 저장시킨다.

### 3.5 updateHostRoot()

beginWork()에서 HostRoot의 렌더링을 시작할 때 호출하는 함수다.

`processUpdateQueue()`에서 업데이트를 처리한다.

`reconcileChildren()`을 호출하고 workInProgress.child를 반환하여 다음에 전역 변수 workInProgress에 저장될 FiberNode를 반환한다.

### 3.6 reconcileChildren()

reconcile은 diff와 같은 의미로 사용된다.

updateHostRoot()에서 reconcileChildren()을 호출할 때, current와 workInProgress 트리에는 각각 HostRoot가 존재한다.

따라서 current가 null이 아니기 때문에 reconcileChildFibers()를 호출하고 전역 변수 workInProgress의 child에 새로운 FiberNode를 추가한다.

### 3.7 reconcileChildFibers() vs mountChildFibers().

reconcile의 목표는 이미 가지고 있는 것을 재사용하는 것이다.

mount는 아무것도 재사용하지 않으므로 reconcile의 특별한 버전으로 생각할 수 있다.

구현체를 보면 두 함수는 shouldTrackSideEffects 플래그를 제외하고는 같은 클로저 함수를 사용하고 있다.

updateHostRoot() 실행 플로우에서 reconcileChildFibersImpl()에 전달되는 newChild는 `<App />`이고, 이것은 REACT_ELEMENT_TYPE이다.

reconcileXXX()에서는 diffing을 진행하고, placeSingleChild()에서는 DOM에 삽입되어야 한다는 표시를 FiberNode에 하게 된다.

### 3.8 reconcileSingleElement()

updateHostRoot() 실행 플로우에서 returnFiber는 workInProgress, currentFirstChild는 current.child, element는 App이다.

current.child가 null이기 때문에 diffing의 복잡한 과정들은 생략되고, App에 해당하는 FiberNode를 생성하여 반환만 하게 된다.

createFiberFromElement()에서 새로운 FiberNode를 생성하게 되면 그 tag는 IndeterminateComponent가 된다.

### 3.9 placeSingleChild()

새로 만든 FiberNode의 flags에 Placement를 추가하여 DOM에 삽입되어야 한다고 표시한다.

이 과정은 오직 initial mount에서 HostRoot 노드에만 해당된다.

왜냐하면, 루트만 삽입해도 나머지는 연결되어 있기 때문에 자동적으로 삽입되기 때문이다.

따라서 mountChildFibers()에서는 이 과정을 거치지 않고 효율적으로 진행하게 된다.

### 3.10 mountIndeterminateComponent()

HostRoot의 child가 생성되었으므로, 이제 다시 performUnitOfWork()가 실행되고 beginWork()가 시작된다.

beginWork()에서 workInProgress의 tag는 IndeterminateComponent이다.

따라서 mountIndeterminateComponent()가 실행된다.

여기서는 다루지 않지만, renderWithHooks()를 실행하여 함수형 컴포넌트를 실행하고 children 엘리먼트를 반환 받는다.

이제 workInProgress의 tag를 FunctionComponent로 변경하고, reconcileChildren()을 호출한다.

이때, current를 null로 전달해서 mountChildFibers()가 사용되도록 한다.

마찬가지로 workInProgress의 다음 노드를 처리하도록 workInProgress.child를 반환하고 마무리된다.

여기서 workInProgress.child는 App이 반환한 div가 되며, HTML 태그에 해당하는 FiberNode의 tag는 `HostComponent`가 된다.

### 3.11 updateHostComponent()

다시 돌아와서 beginWork()가 호출되고, 현재 workInProgress의 tag가 HostComponent이므로, updateHostComponent()가 호출된다.

nextProps는 workInProgress의 pendingProps이며 엘리먼트의 props에 해당한다.

nextProps에서 children을 살펴보면, \<div/\>의 props.children인 \<p/\>를 확인할 수 있다.

reconcileChildren()을 호출하는 과정은 계속 반복되는데, div의 자식인 p에서 실행되고 또 p의 자식인 \[Link, br, button\] 배열에서 실행된다.

다만 children이 배열인 경우 REACT_ELEMENT_TYPE이 아니기 때문에 reconcileChildFibersImpl()에서 reconcileChildrenArray()로 진행하는데, 여기서 `key`를 다루게 된다.

지금은 이에 대해서 자세하게 살펴보지 않는다.

돌아와서, Link의 경우 App과 같은 과정을 거친다.

a와 button의 경우 조금 다르게 진행된다.

a의 경우 정적인 텍스트가 children인 반면, button은 JSX 표현인 `{count}`를 가지고 있다.

따라서 a의 nextChildren은 null이 되고, button의 nextChildren은 null이 아니라 계속 진행된다.

### 3.12 updateHostText()

button의 children은 배열이다. (`["click me - ", "0"]`)

따라서 beginWork()에서 updateHostText()가 실행된다.

### 3.13 DOM nodes are created offscreen in completeWork().

completeWork()는 sibling이 beginWork()를 호출하기 전에 호출된다.

FiberNode의 stateNode는 HTML 태그의 경우(tag가 HostComponent인 경우) 실제 DOM 노드를 가리킨다.

실제 DOM 노드의 생성은 completeWork()의 createInstance()에서 `docuement.createElement()`를 사용하여 만들어진다.

DOM노드를 생성했으면, appendAllChildren()을 통해 부모와 연결한다.

text의 경우(tag가 HostText인 경우) FiberNode의 stateNode는 createTextInstance()에서 `docuement.createTextNode()`로 생성한 새로운 텍스트 노드가 된다.

button과 a의 경우 다르게 진행되는데 button은 HostText 브랜치로 가고, a는 HostComponent로 간다.

## 4. Ininital mount in Commit phase

지금까지 진행사항은 아래와 같다.

1. workInProgress Fiber 트리가 완전히 구성되었다.
2. 그에 해당하는 DOM 노드가 생성되고 조직화되었다.
3. DOM 조작이 필요한 FiberNode에 flag가 설정되었다.

### 4.1 commitMutationEffects()

commitMutationEffects()에서는 DOM 조작을 다룬다.

finisedWork는 workInProgress Fiber 트리의 루트이며, commitMutationEffectsOnFiber()를 호출한다.

여기서는 FiberNode의 tag에 따라 다른 플로우가 진행된다.

### 4.2 commitReconciliationEffects()

여기서는 삽입을 진행한다.

App의 FiberNode가 실제로 커밋된다.

### 4.3 commitPlacement()

finishedWork의 DOM노드를 부모 컨테이너의 올바른 위치에 삽입(insert)하거나 추가(append)한다.

이제 DOM이 마침내 삽입되었다.
