import { CodeSelector } from '@/components/code-selector.tsx'

## How does React re-render internally?

> https://jser.dev/2023-07-18-how-react-rerenders/ 를 읽고 정리해본 글.

아래 코드가 re-render에서 어떻게 동작하는지에 대해 살펴본다.

<CodeSelector names={['App.jsx']} desc='ex1' />

```jsx showLineNumbers
import { useState } from 'react'

function Link() {
  return <a href='https://jser.dev'>jser.dev</a>
}

function Component() {
  const [count, setCount] = useState(0)

  const handleClick = () => {
    setCount((prev) => prev + 1)
  }
  return (
    <div>
      <button onClick={handleClick}>click me - {count}</button> (
      {count % 2 === 0 ? <span>even</span> : <b>odd</b>})
    </div>
  )
}

export default function App() {
  return (
    <div>
      <Link />
      <br />
      <Component />
    </div>
  )
}
```

## 1. Re-render in Trigger phase

initial mount에서 Fiber 트리와 DOM 트리를 만들었다.

re-render는 여기서부터 시작하게 된다.

### 1.1 lanes and childLanes

`Lane`은 보류된 작업의 우선순위를 나타낸다.

lanes은 FiberNode 자신에 대한 것이고, childLanes는 그 서브트리에 대한 것이다.

setState를 호출하면, current 트리의 루트부터 타겟 FiberNode까지 가는 경로에 lanes와 childLanes가 마킹된다.

업데이트는 scheduleUpdateOnFiber()에 의해 스케쥴되고, ensureRootIsScheduled()가 호출되면 performConcurrentWorkOnRoot()는 Scheduler에 스케쥴된다.

이벤트의 우선순위는 업데이트의 우선순위를 결정한다.

click 이벤트의 경우, DiscreteEventPriority이고 높은 우선순위인 SyncLane으로 연결된다.

## 2. Re-render in Render phase

### 2.1 Basic rendering logic is the same as initial mount.

SyncLane은 blocking lane이므로 performConcurrentWorkOnRoot()에서 concurrent mode로 동작하지 않는다.

### 2.2 React reuses redundant Fiber Nodes before creating new ones

initial mount에서는 FiberNode를 처음부터 만들었지만, re-render에서는 재사용하려고 노력한다.

prepareFreshStack()에서 current 트리의 HostRoot를 복사한다.

### 2.3 The Update branch in beginWork()

re-render에서는 current가 null이 아니므로, props가 변경되었는지 확인한다.

그리고 Fiber에 업데이트가 있는지 확인하고 없다면 React는 여기서 렌더링을 끝낸다. (bailout)

### 2.4 Bailout logic inside attemptEarlyBailoutIfNoScheduledUpdate()

이름과 같이 불필요한 렌더링을 끝내는 함수다.

1. FiberNode가 props/context 변경이 없고, pending work가 없다면 (empty lanes) children을 살펴본다.
   - children도 pending work가 없다면 (empty childLanes) 더 이상 진행하지 않고 끝낸다.
   - children의 pending work가 있다면 이 FiberNode의 re-render를 진행하지 않고 자식으로 넘어간다.
2. props/context 변경 또는 pending work가 있다면, re-render를 하고 자식으로 넘어간다.

### 2.5 memoizedProps vs pendingProps

memoizedProps는 현재 props이고, pendingProps는 다음 props로 생각해 볼 수 있다.

re-render가 끝나면, performUnitOfWork()에서 memoizedProps가 pendingProps로 설정된다.

Component에 해당하는 FiberNode에는 lanes가 1이고 childLanes가 0이기 때문에 현재 노드를 렌더링한다.

### 2.6 updateFunctionComponent() re-renders function components and reconcile children

`<Component />`는 div 하나를 반환하고 있다.

(initial mount에서 다룬 부분은 빠르게 넘어간다.)

### 2.7 reconcileSingleElement()

div의 elementType이 current와 비교해서 달라지지 않았다면 FiberNode를 재사용할 수 있다.

재사용할 때, props는 pendingProps로 변경해서 사용한다.

### 2.8 Once a component is re-rendered, their subtree is re-rendered by default

컴포넌트가 렌더링될 때마다 React 엘리먼트를 포함한 새로운 객체를 생성하기 때문에 pendingProps는 매번 새로 생성된다.

따라서 bailout은 발생하지 않고 updateHostComponent()가 실행된다.

### 2.9 updateHostComponent()

재렌더링을 하면 span은 b로 바뀐다.

따라서 nextChildren에는 b가 들어있고, current의 memoizedProps에는 span이 있다.

## 2.10 reconcileChildrenArray() creates and deletes fibers as needed

reconcileChildrenArray()에서 key가 존재하면 엘리먼트의 재정렬이 있는지 확인하고 fiber를 재사용하는 최적화를 진행한다.

그런데 예제 코드에서는 key가 없으므로 이 과정은 진행되지 않는다.

current는 span이므로 b로 교체하기 위해서 deleteChild()로 커밋 단계에서 삭제할 것을 표시해둔다.
