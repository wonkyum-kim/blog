import Image from 'next/image'
import { CodeSelector } from '@/components/code-selector.tsx'
import { ImageContainer } from '@/components/image-container/image-container.tsx'
import pic4 from '/public/React/r4.jpeg'

## Initial mount in Trigger phase

`createRoot()`는 비어있는 HostRoot를 가지고 있는 `current Fiber 트리`를 생성한다.

`root.render(<App />)`은 HostRoot의 업데이트를 스케줄한다.

<CodeSelector names={['index.js']} desc='ex1' />

```js showLineNumbers
import { useState } from 'react'
import { createRoot } from 'react-dom/client'

function App() {
  const [count, setCount] = useState(0)
  const handleClick = () => {
    setCount((prev) => prev + 1)
  }
  return <button onClick={handleClick}>{count}</button>
}

const root = createRoot(document.getElementById('root'))
/**
 *                   current
 *                 ---------->
 * FiberRootNode                HostRoot
 *                 <----------
 *                  stateNode
 */

root.render(<App />)
```

root.render()에서는 Update 객체를 생성하고, 큐에 넣고 아래와 같은 실행 과정을 거쳐서 마이크로태스크 큐에 업데이트를 실행하는 콜백 함수(`processRootScheduleInMicrotask()`)를 넣는다.

1. scheduleUpdateOnFiber()
2. markRootUpdated()
3. ensureRootIsScheduled()

<CodeSelector names={['ensureRootIsScheduled', 'scheduleImmediateTask']} desc='schedule' />

```ts showLineNumbers {13-14, 31-34}
export function ensureRootIsScheduled(root: FiberRoot): void {
  // This function is called whenever a root receives an update. It does two
  // things 1) it ensures the root is in the root schedule, and 2) it ensures
  // there's a pending microtask to process the root schedule.
  //
  // Most of the actual scheduling logic does not happen until
  // `scheduleTaskForRootDuringMicrotask` runs.

  // Add the root to the schedule
  if (root === lastScheduledRoot || root.next !== null) {
    // Fast path. This root is already scheduled.
  } else {
    if (lastScheduledRoot === null) {
      firstScheduledRoot = lastScheduledRoot = root
    } else {
      lastScheduledRoot.next = root
      lastScheduledRoot = root
    }
  }

  // Any time a root received an update, we set this to true until the next time
  // we process the schedule. If it's false, then we can quickly exit flushSync
  // without consulting the schedule.
  mightHavePendingSyncWork = true

  // At the end of the current event, go through each of the roots and ensure
  // there's a task scheduled for each one at the correct priority.

  // ...
  else {
    if (!didScheduleMicrotask) {
      didScheduleMicrotask = true
      scheduleImmediateTask(processRootScheduleInMicrotask)
    }
  }
}
```

```ts showLineNumbers {3-9}
function scheduleImmediateTask(cb: () => mixed) {
  // ...
  if (supportsMicrotasks) {
    // scheduleMicrotask()는 queueMicrotask()와 같다.
    scheduleMicrotask(() => {
      // ...
      cb()
    })
  }
  // ...
}
```

다른 코드를 실행하다가 호출 스택이 비어있으면, 마이크로태스크 큐에 있던 콜백 함수를 실행시킨다.

이 과정에서 `performWorkUntilDeadline()`은 `performConcurrentWorkOnRoot()`를 호출하며 렌더링이 시작된다.

## Initial mount in Render Phase

### performConcurrentWorkOnRoot()

`performConcurrentWorkOnRoot()`는 initial mount와 re-render에서 렌더링을 시작하는 진입 점이다.

이름과 달리, 필요하면 sync로 진행되는데, sync로 렌더링을 진행해야 하는 경우는 `lane`을 보고 판단할 수 있다.

Initial mount의 경우 `DefaultLane`에 해당하는데, blocking lane이라서 sync로 진행한다.

(blocking lane은 렌더링이 인터럽트 되지 않아야 한다는 것을 의미한다.)

<CodeSelector names={['performConcurrentWorkOnRoot']} desc='pcwr1' />

```ts showLineNumbers {8}
const shouldTimeSlice =
  !includesBlockingLane(root, lanes) &&
  !includesExpiredLane(root, lanes) &&
  (disableSchedulerTimeoutInWorkLoop || !didTimeout)

let exitStatus =
  // lanes가 DefaultLane이라서 renderRootSync로 진행된다.
  shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes)
```

### renderRootSync()

초기 마운트의 경우 sync 모드로 진행되기 때문에 `renderRootSync()`가 호출된다.

여기서 크게 두 가지 함수가 호출된다.

1. prepareFreshStack()
2. workLoopSync()

<CodeSelector names={['renderRootSync']} desc='renderRootSync1' />

```ts showLineNumbers {4, 10}
// root나 lanes가 바뀌면 prepareFreshStack()을 호출한다.
if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
  // ...
  prepareFreshStack(root, lanes)
}

do {
  try {
    // ...
    workLoopSync()
    break
  } catch (thrownValue) {
    handleThrow(root, thrownValue)
  }
} while (true)
```

### prepareFreshStack()

렌더링을 시작하기 전 준비를 하는 곳이다.

React에는 현재 작업 중인 Fiber 트리의 노드를 가리키는 포인터인 workInProgress라는 전역 포인터 변수가 있는데, 이 포인터가 HostRoot를 가리키도록 초기화한다.

(앞으로 workInProgress 트리와 구분하기 위해서 workInProgress 포인터라고 부르겠다.)

전역 변수이기 때문에 다른 함수에서도 현재 작업 중인 Fiber 노드에 접근할 수 있게 되는 것이다.

### performUnitOfWork()

`workLoopSync()`는 그냥 while 루프이며, workInProgress 포인터가 null이 될 때까지 실행된다.

workInProgress 포인터는 Fiber 트리를 전위 순회(preorder traversal) 방식으로 이동한다.

즉, 자식이 있으면 자식부터 이동하고 없으면 다음 형제 노드로 이동하는 dfs와 같다.

workInProgress 포인터가 null이 된다는 의미는 결국 모든 노드를 다 순회했다는 의미가 된다.

아직 HostRoot 밖에 없는 미완성 트리에서 순회를 어떻게 할 수 있는 것인가? 라는 생각을 할 수 있다.

Fiber 트리는 workInProgress 포인터가 이동하기 이전에 트리에 새로운 노드를 추가한다.

다시 본론으로 돌아와서, while 루프 안에서 workInProgress 포인터가 가리키는 Fiber 노드에 대해서 `performUnitOfWork()`를 실행한다.

<CodeSelector names={['workLoopSync']} desc='workLoopSync' />

```ts showLineNumbers
// The work loop is an extremely hot path. Tell Closure not to inline it.
/** @noinline */
function workLoopSync() {
  // Perform work without checking if we need to yield between fiber.
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress)
  }
}
```

performUnitOfWork()에서 workInProgress 포인터가 가리키고 있는 노드에 대해 `beginWork()`가 호출된다.

beginWork()의 반환 값은 현재 가리키고 있는 노드의 자식 노드가 된다.

<CodeSelector names={['performUnitOfWork']} desc='performUnitOfWork' />

```ts showLineNumbers
// next는 child 노드가 된다.
next = beginWork(current, unitOfWork, entangledRenderLanes)

// next가 null이면, completeUnitOfWork()에서 completeWork()를 실행한다.
// sibling이 있으면 sibling으로 넘어간다.
if (next === null) {
  completeUnitOfWork(unitOfWork)
}
// child로 넘어간다.
else {
  workInProgress = next
}
```

### 1. beginWork()

`beginWork()`는 workInProgress 포인터가 가리키는 노드의 실제 렌더링이 진행되는 곳이다.

노드의 렌더링은 tag에 따라서 다른 플로우로 진행된다.

지금부터는 각 함수가 실행되는 순서에 따라서 글을 작성하도록 한다.

### 2. updateHostRoot()

현재 노드의 tag가 HostRoot이기 때문에 beginWork()에서 `updateHostRoot()`가 실행된다.

### 3. reconcileChildren()

updateHostRoot()는 `reconcileChildren()`를 호출한다.

reconcile은 diff와 같은 의미로 사용된다.

이전과 비교할 것이 없다면 mount 상황이고, 있다면 re-render 상황이라는 의미가 된다.

전자의 경우 `mountChildFibers()`가 호출되고, 후자의 경우 `reconcileChildFibers()`가 호출된다.

단, HostRoot의 경우에는 mount 상황이라도 reconcileChildFibers()가 호출된다.

### 4. reconcileChildFibers()

이 함수의 역할은 재렌더링을 통해 새로운 Fiber 노드를 만들고 부모 노드와 연결시키는 것이다.

지금 여기서 새로 만든 노드는 App 컴포넌트에 해당하는 Fiber 노드이고 이런 노드의 tag는 `FunctionComponent`가 된다.

그리고 새로 만든 노드의 부모(return)를 HostRoot로 설정한다.

<CodeSelector names={[]} desc='rel' />

```text
           return
HostRoot <-------- FunctionComponent
```

### 5. placeSingleElement()

새로 만든 Fiber 노드(FunctionComponent)의 flags에 `Placement`를 추가하여 DOM에 삽입되어야 한다고 표시한다.

<CodeSelector names={[`placeSingleChild`]} desc='psc' />

```ts {4}
// newFiber: <App />에 해당하는 FunctionComponent
function placeSingleChild(newFiber: Fiber): Fiber {
  if (shouldTrackSideEffects && newFiber.alternate === null) {
    newFiber.flags |= Placement | PlacementDEV
  }
  return newFiber
}
```

모든 Fiber 노드에 대해서 추가될 때마다 flags를 수정하지는 않고 루트에 해당하는 것만 이 과정을 거치게 된다.

### 6. beginWork()

이제 performUnitOfWork()에서 workInProgress 포인터가 \<App /\>에 해당하는 FunctionComponent를 가리키게 되고, while문 안에서 다시 performUnitOfWork()와 beginWork()가 호출된다.

### 7. updateFunctionComponent()

beginWork()에서 workInProgress 포인터가 가리키는 Fiber의 tag가 FunctionComponent 이므로 `updateFunctionComponent()`가 실행되는 플로우로 진행된다.

### 8. renderWithHooks()

`renderWithHooks()` 에서는 이름과 컴포넌트와 훅을 같이 렌더링한다.

일반적으로 쓰는 useState(뿐만 아니라 모든 다른 리액트 훅도 마찬가지다.)는 그 상황에 따라서 각각 다른 구현체가 사용된다.

앞으로 컴포넌트에서 사용될 리액트 훅을 `ReactSharedInternals.H`에 저장해둔다.

지금 마운트 상황에서는 `HooksDispatcherOnMount`가 저장된다.

사용할 리액트 훅 구현체를 저장한 다음, App 함수를 실행시킨다.

<CodeSelector names={[`renderWithHooks`, `App`]} desc='rwh1' />

```ts {3, 9} showLineNumbers
ReactSharedInternals.H =
  null === current || null === current.memoizedState
    ? HooksDispatcherOnMount
    : HooksDispatcherOnUpdate

// ...

// Component는 현재 App이다.
current = Component(props, secondArg)
```

```js {2, 6} showLineNumbers
function App() {
  const [count, setCount] = useState(0)
  const handleClick = () => {
    setCount((prev) => prev + 1)
  }
  return <button onClick={handleClick}>{count}</button>
}
```

App()을 실행시키면 `useState()`를 실행하고, `<button>`에 해당하는 React 엘리먼트를 만든다.

### 9. useState()

렌더링 과정에서는 useState()가 어떤 흐름으로 호출되는지만 살펴보고 자세한 과정은 다른 글에서 살펴보기로 한다.

useState()를 실행시키면, 아까 ReactSharedInternals.H에 저장해둔 훅(HooksDispatcherOnMount)을 사용한다.

<CodeSelector
  names={[`useState`, `HooksDispatcherOnMount`, `mountStateImpl`, `mountWorkInProgressHook`]}
  desc='useState'
/>

```ts showLineNumbers {2}
exports.useState = function (initialState) {
  return ReactSharedInternals.H.useState(initialState)
}
```

```ts showLineNumbers {4, 6, 8}
const HooksDispatcherOnMount = {
  // ...
  useState: function (initialState) {
    initialState = mountStateImpl(initialState)
    var queue = initialState.queue,
      dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue)
    queue.dispatch = dispatch
    return [initialState.memoizedState, dispatch]
  },
  // ...
}
```

```ts showLineNumbers {2}
function mountStateImpl(initialState) {
  var hook = mountWorkInProgressHook()

  // 초기화 함수를 전달했을 때 실행된다.
  if ('function' === typeof initialState) {
    var initialStateInitializer = initialState
    initialState = initialStateInitializer()
  }
  hook.memoizedState = hook.baseState = initialState
  hook.queue = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState,
  }
  return hook
}
```

```ts showLineNumbers {10}
function mountWorkInProgressHook() {
  var hook = {
    memoizedState: null, // useState에 저장되어 있는 값
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  }
  null === workInProgressHook
    ? (currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook)
    : (workInProgressHook = workInProgressHook.next = hook)
  return workInProgressHook
}
```

### 10. createElement()

button을 만들기 위해서 `createElement()`가 실행된다.

### 11. finishRenderingHooks()

renderWithHooks()의 마지막에 호출되며, ReactSharedInternals.H에 있는 훅을 지우는 과정을 거친다.

### 12. reconcileChildren()

updateFunctionComponent()로 돌아와서 마지막으로 reconcileChildren()이 호출된다.

이번에는 mountChildFibers()가 호출된다.

### 13. mountChildFibers()

HostComponent의 return을 FunctionComponent로 만들고 끝이 난다.

<CodeSelector names={[]} desc='rel2' />

```text
           return                       return
HostRoot <-------- FunctionComponent  <-------- HostComponent
                        (App)                     (button)
```

### 14. beginWork()

다시 beginWork()가 실행되고, updateHostComponent()가 실행된다.

### 15. updateHostComponent()

마찬가지로 reconcileChildren(), mountChildFibers()가 실행된다.

### 16. completeUnitOfWork()

### mountIndeterminateComponent()

HostRoot의 child가 존재한다면, workInProgress가 null이 아니라서 renderRootSync()의 while 루프가 계속 실행된다.

따라서 다시 performUnitOfWork()가 실행되고 beginWork()가 실행되는 과정이 반복된다.

아까 새로 만든 workInProgress.tag는 IncompleteFunctionComponent이므로, `mountIncompleteFunctionComponent()`가 실행된다.

이제 workInProgress의 tag를 `FunctionComponent`로 변경하고, `updateFunctionComponent()`을 호출한다.

여기서는 다루지 않지만, `renderWithHooks()`를 실행하여 함수형 컴포넌트를 실행하고 children 엘리먼트를 반환 받는다.

이때, current를 null로 전달해서 mountChildFibers()가 사용되도록 한다. (즉, `<App />`이 mount 된다.)

여기서 workInProgress.child는 App이 반환하는 것이 div라 치면, HTML 태그에 해당하는 FiberNode의 tag는 `HostComponent`가 된다.

### updateHostComponent()

마찬가지로 다시 돌아와서 beginWork()가 호출되고, 현재 workInProgress의 tag가 HostComponent이므로, `updateHostComponent()`가 호출된다.

이 과정은 Fiber 트리가 완성될 때까지 비슷한 플로우로 반복된다.

### completeWork()

`completeWork()`는 sibling이 beginWork()를 호출하기 전에 호출된다. 즉, dfs 트리에서 더 이상 탐색할 자식 노드가 없으면 종료하는 것과 같다.

FiberNode의 stateNode는 HTML 태그의 경우(tag가 HostComponent인 경우) 실제 DOM 노드를 가리킨다.

실제 DOM 노드의 생성은 completeWork()의 createInstance()에서 `docuement.createElement()`를 사용하여 만들어진다.

DOM노드를 생성했으면, `appendAllChildren()`을 통해 부모와 연결한다.

## Ininital mount in Commit phase

<ImageContainer>
  <Image
    src={pic4}
    alt='completeWork'
    sizes='100vw'
    style={{
      width: '85%',
      height: 'auto',
    }}
  />
</ImageContainer>

지금까지 진행사항은 아래와 같다.

1. workInProgress Fiber 트리가 완전히 구성되었다.
2. 그에 해당하는 DOM 노드가 생성되고 조직화되었다.
3. DOM 조작이 필요한 FiberNode에 flag가 설정되었다.

### commitMutationEffects()

`commitMutationEffects()`에서는 DOM 조작을 다룬다.

finisedWork는 workInProgress Fiber 트리의 루트이며, commitMutationEffectsOnFiber()를 호출한다.

Fiber 트리를 만드는 것은 탑 다운이었지만, DOM 트리를 만드는 것은 바텀 업으로 진행된다.

그 이유는 html에 루트 노드 하나만 추가하면 더 간단하기 때문이다.

이 과정은 `recursivelyTraverseMutationEffects()`에서 확인할 수 있다.

### commitReconciliationEffects()

여기서는 삽입을 진행한다. App의 FiberNode가 실제로 커밋된다.

DOM 트리가 바텀 업으로 생성되었기 때문에 App에 해당하는 DOM만 추가해주면 된다.

### commitPlacement()

finishedWork의 DOM노드를 부모 컨테이너의 올바른 위치에 삽입(insert)하거나 추가(append)한다.

이제 DOM이 마침내 삽입되었다.

## References

- https://jser.dev/2023-07-14-initial-mount/
