import { CodeSelector } from '@/components/code-selector.tsx'

## 개념

blocking과 non blocking은 `제어권`을 누가 가지느냐에 따라 달라지는 개념이다.

- blocking은 호출된 함수가 제어권을 가지기 때문에 호출한 함수는 호출된 함수의 작업이 완료될 때까지 대기해야한다.
- non blocking은 호출한 함수가 제어권을 가지기 때문에 호출한 함수는 호출된 함수의 작업의 완료 여부와 상관 없이 자신의 작업을 계속 한다.

sync와 async는 누가 작업 완료를 `확인`하는가에 따라 달라지는 개념이다.

- sync는 호출한 함수가 호출된 함수의 작업의 완료를 확인하고 결과를 가져온다.
- async는 호출된 함수에서 작업의 완료를 확인하고 결과를 처리한다.

이것을 조합하면 총 4가지 경우가 나온다.

- blocking & sync: 호출한 함수는 호출된 함수가 완료될 때까지 대기한다. 호출된 함수의 작업이 완료되면 호출한 함수는 결과를 받아 이어나간다.
- blocking & async: 호출한 함수는 호출된 함수가 완료될 때까지 대기한다. 호출된 함수의 작업이 완료되면 호출된 함수에서 결과를 처리한다.
- non blocking & sync: 호출한 함수는 호출된 함수의 작업의 완료 여부와 상관 없이 자신의 작업을 계속 한다. 호출한 함수는 호출된 함수의 작업 완료 여부를 확인하고 완료되면 결과를 받아 처리한다.
- non blocking & async: 호출한 함수는 호출된 함수의 작업의 완료 여부와 상관 없이 자신의 작업을 계속 한다. 호출된 함수의 작업이 완료되면 호출된 함수에서 결과를 처리한다.

## Node.js

Node.js에서 "I/O"란, 시스템의 디스크와 libuv에 의해 지원되는 네트워크의 상호작용을 의미한다.

Node.js 프로세스에서 추가적인 자바스크립트 실행이 자바스크립트가 아닌 작업이 완료될 때 까지 기다려야 하는 경우를 블로킹이라고 한다.

이는 블로킹 작업이 진행되는 동안 이벤트 루프가 자바스크립트를 실행할 수 없기 때문에 발생한다.

즉, Node.js에서 단순히 CPU를 많이 사용하여 성능이 저하되는 경우는 블로킹이 아니며, I/O와 같이 `자바스크립트가 아닌 작업을 기다리는 것이 블로킹이다.`

libuv를 사용하는 Node.js 표준 라이브러리의 동기 메서드는 가장 일반적으로 사용되는 블로킹 연산이다.

Node.js 스탠다드 라이브러리의 모든 I/O 메서드는 논블로킹 비동기 버전을 제공한다.

<CodeSelector names={['blocking & sync', 'non blocking & async']} desc='ex1' />

```js
const fs = require('node:fs')

// 블로킹, 동기적으로 파일을 읽는 방법:
const data = fs.readFileSync('/file.md')

// 전체 파일을 다 읽을 때까지 추가적인 자바스크립트 실행이 차단된다.
console.log(data)
moreWork()
```

```js
const fs = require('node:fs')

// 논블로킹, 비동기적으로 파일을 읽는 방법:
fs.readFile('/file.md', (err, data) => {
  if (err) throw err
  console.log(data)
})

// 차단되지 않고 바로 실행된다.
moreWork()
```

## References

- https://black7375.tistory.com/90
- https://nodejs.org/en/learn/asynchronous-work/overview-of-blocking-vs-non-blocking
